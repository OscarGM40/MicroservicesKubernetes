										   SECCION 20 WORKER SERVICES

				VIDEO 420 THE EXPIRATION SERVICE

Vamos a seguir atados al backend por un tiempo más.Seguiremos por el Expiration Service,el cual tendrá una única tarea que es vigilar por el tiempo de expiración.
Cuando se cumpla que ha expirado emitirá un único evento también, de tipo expiration:complete.Su objetivo es informar al resto de servicios.
Su objetivo no es cancelar una orden,ojo,eso es para el Orders srv,él sólo informa del tiempo de expiración.
Realmente va a ser un srv muy sencillo pues no va a usar express ni rutas,simplemente escuchará por el order:created y emitirá el expiration:complete.

					VIDEO 421 EXPIRATION OPTIONS

La única complejidad de este servicio es como controlar este tiempo,y como emitir justo un evento 15 minutos despues.Hay varias opciones que vamos a contemplar en este video

NOTA: recuerda que el campo a tratar es orderId: order.expiresAt.toISOString(y este campo en el Schema es un simple Date  expiresAt:{ type: mongoose.Schema.Types.Date }).

OPCION UNO: usar un setTimeout( () => {},'15m') => no es una opción válida porque el contador se acumula en la memoria.Si de alguna manera se reiniciará el servicio comenzaría esa cuenta de nuevo(perdería todos los temporizadores,ya que se reinician).

OPCION DOS: poner un LIstener en el Orders srv y si a la hora de realizar una operación el tiempo que arroja ese Listener(que será cuando expira) es mayor que el campo expiresAt caducó y está expirado.
Si aún es mayor es que no ha caducado aún y se puede editar.El downside es que lo gestionará NATS y chocará con el mecanismo de cúantas veces permitiremos que un evento rebote,ya que su  lógica no es la misma que un evento común(la primera vez que rebote es suficiente)

OPCION TRES: la opción tres sería que el broker(el event-bus) tuviera ya esa funcionalidad implementada y pudiera esperar 15 minutos para emitir un evento.(esta idea es conocida como 'scheduled message' o 'scheduled event').NATS no la soporta.

Lo que vamos a hacer es usar una librería de propósito general llamada Bull JS que sirve para crear tareas sincronizadas(y disparar alguna lógica cuando se cumpla ese timer).Usaremos una instancia de Redis para almacenar esta tarea.
Redis es una base de datos en memoria,es muy común usarla para tareas.Lo que haremos será guardar con Bull JS una lista de jobs.Recuerda que la propia libreria Bull me avisará que ha terminado la countdown.

							VIDEO 422 INITIAL SETUP

Elimino todas las dependencias de express,cookies,... e instalo las nuevas:
>npm i bull @types/bull
NOTA: recuerda que en k8s no se usan .env.Las variables de entorno se declaran en los yaml( if (!process.env.NATS_CLIENT_ID) <- estará en algún yaml)
Simplemente es seguir el video

					VIDEO 424 KUBERNETES SETUP

Sigamos por la docker Image y por su Deploy además del Service para Redis en k8s.
Fijate que el deploy de redis va a ser un poco diferente,ya que no necesito contactar con la DB,no usaré un Service,la comunicación será con el NATS.

apiVersion: apps/v1
kind: Deployment
metadata:
  name: expiration-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: expiration
  template:
    metadata:
      labels:
        app: expiration
    spec:
      containers:
        - name: expiration
          image: oscargm40/expiration-ticketing-k8s:latest
          imagePullPolicy: Always  
          env:
            - name: NATS_URL
              value: 'http://nats-srv:4222'
            - name: NATS_CLUSTER_ID
              value: ticketing
            - name: NATS_CLIENT_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name 
            - name: REDIS_HOST
              value: 'expiration-redis-srv'

Para el Deploy+Service de Redis me vale el de Mongo pero con la imagen 'redis' y con las variables que necesite.Pan comido,asin.

					VIDEO 425 FILE SYNC SETUP

Aún me falta actualizar el skaffold.yaml con el nuevo microservicio:
    - image: oscargm40/expiration-ticketing-k8s
      context: expiration
      docker:
        dockerfile: Dockerfile
      sync:
        manual: 
          - src: 'src/**/*.js'
            dest: .
REinicio todo y compruebo que los servicios se conectan a sus DBs y a NATS.Todo perfecto,asinto

						VIDEO 426 LISTENER CREATION

Vamos a empezar creando el listener para el order:created. 

import { Listener, OrderCreatedEvent, Subjects } from '@oscargmk8s/common';
import { Message } from 'node-nats-streaming';
import { queueGroupName } from './queue-group-name';

export class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  readonly subject = Subjects.OrderCreated;
  queueGroupName = queueGroupName;

  async onMessage(data: OrderCreatedEvent['data'], msg: Message) {

  }
					
				VIDEO 427 WHAT'S BULL ALL ABOUT?

Normalmente se suele tener una request(por ejemplo,convertir un mp4 a mkv).En vez de simplemente ejecutar esa tarea inmediatamente,se suele tener un Worker Server,algo que se ocupa de esta tarea(y puedo tener varias copias de este servicio).
Cuando se hace esta petició se crea un job,que no es más que un plain object de JS,incluyendo las demandas que necesita para ese job.Este job se va a guardar en la Redis DB y las diferentes replicas del Worker Service van a estar haciendo pull a la DB en cuanto haya un job nuevo
Cuando lo completen informarán de nuevo.Bull JS se ocupa tanto de informar desde el Worker hacia Redis como cuando se crea el job y se guarda en Redis(ver imagen)
NOTA: puede parecer que Bull tiene cierta similitud con NATS ,pero no es asi,no es capaz de procesar una vasta cantidad de mensajes de forma asíncrona,está hecho para gestionar pequeñas tareas
Trabajaremos agregando un job a una queue(una serie o grupo de acciones).Asi que con Bull crearemos Queues y le agregamos un job 

						VIDEO 428 CREATING A QUEUE

Realmente es bastante sencillo crear estas Queues,simplemente hay que importar la clase desde la libreria al proyecto.Despues recibirá el nombre del 'canal' como primer argumento(aunque técnicamente no es un canal,es sólo el nombre del grupo) y como segundo argumento un objeto con las opciones de conexión:

import Queue  from "bull";

interface Payload {
   orderId: string;
}

const expirationQueue = new Queue<Payload>("order:expiration",{
   redis: {
      host: process.env.REDIS_HOST,
   }
})

// job is wrapping the payload,the data,which is orderId:'sfsf' 
expirationQueue.process(async (job) => {
   console.log("I want to publish an expiration:complete event for orderId", job.data.orderId);
});

export { expirationQueue };

Fijate que fácil he creado un tipado para una instancia de una clase pasandole una interfaz como genérico.Cuando tenga cualquier clase puedo pasarle una interfaz para tiparla(class<T>).Increible:
interfaz Casa {
  habitaciones:number;
  metros:number;
  }
class Edificio<Casa> <- cuando haga new Edificio TS me va a ayudar con el tipado.

				VIDEO 429 QUEUEING A JOB ON EVENT ARRIVAL

Recordemos que habiamos dejado el async onMessage(data,msg) sin lógica.Es aqui donde tenemos que ir ahora,pues es en la recepción del order:created cuando hay que hacer algo con Bull + Redis.Es muy sencillo:

 async onMessage(data: OrderCreatedEvent['data'], msg: Message) {
    await expirationQueue.add({
      orderId: data.id,
    });

    msg.ack();
  }
El método expirationQueue.add(data,options) lleva la data a agregar a la cola como primer argumento.El segundo no lo necesitamos.

Aun falta crear la instancia del listener en el index.ts:
 new OrderCreatedListener(natsWrapper.client).listen();

				VIDEO 430 TESTING JOB PROCESSING

Creo un ticket en Postman y despues una Order.Fijate que parece que no es event.version -1 en mi caso.Investigar más.

				VIDEO 431 DELAYING JOB PROCESSING

 Para poner un delay a la hora de agregar el job simplemente uso la propiedad delay como segundo argumento:
      // el tiempo desde el expiresAt hasta el actual
    const delay = new Date(data.expiresAt).getTime() - new Date().getTime();
    await expirationQueue.add({
      orderId: data.id,
    }, {
      delay: delay
    });

			VIDEO 432 DEFINING THE EXPIRATION COMPLETE EVENT

Hay que crear una nueva interfaz y su tipo en el common module:

import { Subjects } from './subjects';

export interface ExpirationCompleteEvent {
   subject: Subjects.ExpirationComplete;
   data: {
      orderId: string;
   };
}
Exporto este archivo en el index,hago una nueva publish y actualizo el expiration folder.

			VIDEO 433 PUBLISHING AN EVENT ON JOB PROCESSING

Creo la clase ExpirationCompletePublisher que hereda de la abstracta del video anterior y en el new Queue<Payload>,en el método process de la instancia llamamos a esta clase,que publicará el evento:

expirationQueue.process(async (job) => {
   new ExpirationCompletePublisher(natsWrapper.client).publish({
      orderId: job.data.orderId,
   });
Fijate que simplemente va a publicar un evento tras X tiempo toda esta lógica.

Hacemos una prueba.Fijate que ahora nos queda recibirlo en el Orders srv o cualquier srv que lo necesite.

				VIDEO 434 HANDLING AN EXPIRATION EVENT

Ahora que ya emitimos el expiration:complete en nuestro Expiration Srv el Orders srv debería marcar esa Order como cancelled.Al cancelarla tendremos que emitir elorder:cancelled también,pero vayamos por lo primero,que es crear un listener en el Orders para el expiration:complete event.

xport class ExpirationCompleteListener extends Listener<ExpirationCompleteEvent> {
   readonly subject = Subjects.ExpirationComplete;
   queueGroupName = queueGroupName;
   
   async onMessage(data: ExpirationCompleteEvent['data'], msg: Message) {
      const order = await Order.findById(data.orderId);
   
      if (!order) {
         throw new Error('Order not found');
      }
   
      if (order.status === OrderStatus.Complete) {
         return msg.ack();
      }
   
      order.set({
         status: OrderStatus.Cancelled,
      });
* Realmente aquí se nos presenta una duda.¿Ponemos el ticket a null dentro de la Order ,dado que se ha cancelado la orden?O lo mantenemos?

				VIDEO 435 EMITTING THE ORDER CANCELLED EVENT 

Poner a null el ticket es una mala idea.Perderemos la información.¿Y si queremos ver el ticket que estaba asociado a una Order aunque está fue cancelada?.

Además ya tengo un método estático en el modelo que me devuelve true o false,es decir, si esta reservado.Si la orden del ticket actual esta en estado Created,Awaiting o Complete devuelve que está reservado(bloqueando su edición,ya que simplemente se ha creado,es decir no hay una orden sobre él,o ya se ha pagado o alguién está intentando pagarlo).

TicketSchema.methods.isReserved = async function () {

   const existingOrder = await Order.findOne({
      ticket: this,
      status: {
         $in: [
            OrderStatus.Created,
            OrderStatus.AwaitingPayment,
            OrderStatus.Complete,
         ]
      }
   })
   return !!existingOrder;
}

Fijate que en cuanto la order se ponga en Cancelled el ticket se considerará NoReservado,desbloqueandolo para su edición,pues vuelve a estar libre.
Fijate que el order:cancelled le interesa al Payment srv,ya que no puede pagarse esa orden más,pues se canceló el pedido.

Asi pues simplemente emitimos el order:cancelled que ya tenemos la clase:

      order.set({
         status: OrderStatus.Cancelled,
      });

      await order.save();

      await new OrderCancelledPublisher(this.client).publish({
         id: order.id,
         version: order.version,
         ticket: {
            id: order.ticket.id,
         },
      });
   
      msg.ack();

IMPORTANTE: fijate en el uso del await new OrderCancelledPublisher ... para asegurarnos que no se llama antes al msg.ack();

		VIDEO 436 TESTING THE EXPIRATION COMPLETE LISTENER

Realmente es un punto crítico de la aplicación este evento,asi que vamos a realizar un par de tests sobre el evento.Como siempre empezamos por la función setup:


const setup = async () => {
   const listener = new ExpirationCompleteListener(natsWrapper.client);

   const ticket = Ticket.build({
      id: mongoose.Types.ObjectId().toHexString(),
      title: 'concert',
      price: 20,
   });

   await ticket.save();

   const order = Order.build({
      status: OrderStatus.Created,
      userId: 'asdf',
      expiresAt: new Date(),
      ticket,
   });

   await order.save();

   const data: ExpirationCompleteEvent['data'] = {
      orderId: order.id,
   };

   // @ts-ignore
   const msg: Message = {
      ack: jest.fn()
   };

   return { listener, order, ticket, data, msg };

}

				VIDEO 437 TESTING AFTER SETUP

Recuerda que hay que llamar a una función extra.Creo los tests:

test('updates the order status to cancelled', async () => {
  const { listener, data, msg, ticket,order} = await setup();
   //  me traigo el setup y llamo al onMessage
  await listener.onMessage(data, msg);
  // simplemente busco la orden y compruebo su status
  const updatedOrder = await Order.findById(order.id);

  expect(updatedOrder!.status).toEqual(OrderStatus.Cancelled);

});

it('emit an OrderCancelled event', async () => {
  const { listener, data, msg, ticket,order} = await setup();

   await listener.onMessage(data, msg);
   // debo esperar que se haya llamado al publish,no?
   expect(natsWrapper.client.publish).toHaveBeenCalled();
   // y que se haya llamado con el id exacto de la Order
   const eventData = JSON.parse((natsWrapper.client.publish as jest.Mock).mock.calls[0][1]);

   expect(eventData.id).toEqual(order.id);

});

Más sencillo de lo que parece,asin.

					VIDEO 438 LISTENING FOR EXPIRATION 

Aun nos falta ponernos a la escucha en el index.ts:
new TicketCreatedListener(natsWrapper.client).listen();
    new TicketUpdatedListener(natsWrapper.client).listen();
    new OrderCancelledListener(natsWrapper.client).listen();

Puedo testearlo en Postman,creando un ticket,despues una orden y debería ver el evento order:cancelled publicado por el Orders srv(pero primero por el Expiration srv).

						SECCION 21 THE PAYMENTS SRV

Recordemos que el payments srv va a estar escuchando por el order:created y el order:cancelled y él mismo va a emitir el charge:created para el Charge srv

					VIDEO 441 INITIAL SETUP

Este srv va a necesitar express,asi que copio según el video desde tickets srv.
Tendrá un MongoDb Service también,aparte de un par de rutas(asi que es otro igual que el tickets o el orders).
REconfiguro el scaffold.yaml y le creo el Deploy y Service para el NOde y la el Deploy+Srv para el Mongo.

					VIDEO 442 REPLICATED FIELDS

El payments srv va a estar escuchando por order:created y order:cancelled y emitirá el charge:created.
También tendrá dos colecciones,una que replicará la de Orders y otra Charge.Asi que resumiendo va a necesitar dos Listener,un publisher y dos Modelos.

Analicemos qué propiedades hay que replicar de una Order:
id: obviamente es lo más importante,debe estar replicada
status:también debe tener conocimiento del estado
version: otro campo fundamental
userId:de nuevo es fundamental saber que usuario debe pagar
expiresAt:realmente tenemos un Servicio que ya emitirá un evento,no es necesario,con la propiedad Status ya nos vale
ticket:{id,price}: ¿necesito el id o el precio?el id realmente no lo necesito,pero el precio sin lugar a dudas.
Resumen:{id,status,version,userId,price}

				VIDEO 443 ANOTHER ORDER MODEL!

Simplemente creamos el modelo:


// interfaz sólo para el tipado
interface OrderAttrs {
   id: string;
   version: number;
   userId: string;
   price: number;
   status: OrderStatus;
}
// en el doc no es necesario el id pues un documento va a tener uno
interface OrderDoc extends mongoose.Document {
   version: number;
   userId: string;
   price: number;
   status: OrderStatus;
}
// el Modelo es la Coleccion,no el documento,lógicamente build es de la coleccion
interface OrderModel extends mongoose.Model<OrderDoc> {
   build(attrs: OrderAttrs): OrderDoc;
}

const OrderSchema = new mongoose.Schema({
   userId: { type: String, required: true, },
   price: { type: Number, required: true, },
   status: { type: String, required: true, },
   // no meto la version porque lo va a gestionar el plugin
   }, {
   toJSON: {
      transform(doc, ret) {
         ret.id = ret._id;
         delete ret._id;
      },
   },
})

OrderSchema.set('versionKey','version');
OrderSchema.plugin(updateIfCurrentPlugin);

OrderSchema.statics.build = (attrs: OrderAttrs) => {

   return new Order({
      _id: attrs.id,
      version: attrs.version,
      price: attrs.price,
      userId: attrs.userId,
      status: attrs.status,
   })
}
 
const Order = mongoose.model<OrderDoc, OrderModel>('Order', OrderSchema);
export { Order };

Fijate que ha declarado status como un String en el Schema pero como una enum en las interfaces.

				VIDEO 445 REPLICATING ORDERS

De nuevo creamos un Listener:

port class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  readonly subject = Subjects.OrderCreated;
  queueGroupName = queueGroupName;

  async onMessage(data: OrderCreatedEvent['data'], msg: Message) {
   // creamos el Order
   const order = Order.build({
      id: data.id,
      price: data.ticket.price,
      status: data.status,
      userId: data.userId,
      version: data.version,
   });
   // guardamos el Order
   await order.save();

   // aseguramos que el evento se recibió y procesó correctamente
   msg.ack();

  }

				VIDEO 446 QUICK TESTING





