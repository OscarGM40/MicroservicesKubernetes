										   SECCION 20 WORKER SERVICES

				VIDEO 420 THE EXPIRATION SERVICE

Vamos a seguir atados al backend por un tiempo más.Seguiremos por el Expiration Service,el cual tendrá una única tarea que es vigilar por el tiempo de expiración.
Cuando se cumpla que ha expirado emitirá un único evento también, de tipo expiration:complete.Su objetivo es informar al resto de servicios.
Su objetivo no es cancelar una orden,ojo,eso es para el Orders srv,él sólo informa del tiempo de expiración.
Realmente va a ser un srv muy sencillo pues no va a usar express ni rutas,simplemente escuchará por el order:created y emitirá el expiration:complete.

					VIDEO 421 EXPIRATION OPTIONS

La única complejidad de este servicio es como controlar este tiempo,y como emitir justo un evento 15 minutos despues.Hay varias opciones que vamos a contemplar en este video

NOTA: recuerda que el campo a tratar es orderId: order.expiresAt.toISOString(y este campo en el Schema es un simple Date  expiresAt:{ type: mongoose.Schema.Types.Date }).

OPCION UNO: usar un setTimeout( () => {},'15m') => no es una opción válida porque el contador se acumula en la memoria.Si de alguna manera se reiniciará el servicio comenzaría esa cuenta de nuevo(perdería todos los temporizadores,ya que se reinician).

OPCION DOS: poner un LIstener en el Orders srv y si a la hora de realizar una operación el tiempo que arroja ese Listener(que será cuando expira) es mayor que el campo expiresAt caducó y está expirado.
Si aún es mayor es que no ha caducado aún y se puede editar.El downside es que lo gestionará NATS y chocará con el mecanismo de cúantas veces permitiremos que un evento rebote,ya que su  lógica no es la misma que un evento común(la primera vez que rebote es suficiente)

OPCION TRES: la opción tres sería que el broker(el event-bus) tuviera ya esa funcionalidad implementada y pudiera esperar 15 minutos para emitir un evento.(esta idea es conocida como 'scheduled message' o 'scheduled event').NATS no la soporta.

Lo que vamos a hacer es usar una librería de propósito general llamada Bull JS que sirve para crear tareas sincronizadas(y disparar alguna lógica cuando se cumpla ese timer).Usaremos una instancia de Redis para almacenar esta tarea.
Redis es una base de datos en memoria,es muy común usarla para tareas.Lo que haremos será guardar con Bull JS una lista de jobs.Recuerda que la propia libreria Bull me avisará que ha terminado la countdown.

							VIDEO 422 INITIAL SETUP

Elimino todas las dependencias de express,cookies,... e instalo las nuevas:
>npm i bull @types/bull
NOTA: recuerda que en k8s no se usan .env.Las variables de entorno se declaran en los yaml( if (!process.env.NATS_CLIENT_ID) <- estará en algún yaml)
Simplemente es seguir el video

					VIDEO 424 KUBERNETES SETUP

Sigamos por la docker Image y por su Deploy además del Service para Redis en k8s.
Fijate que el deploy de redis va a ser un poco diferente,ya que no necesito contactar con la DB,no usaré un Service,la comunicación será con el NATS.

apiVersion: apps/v1
kind: Deployment
metadata:
  name: expiration-depl
spec:
  replicas: 1
  selector:
    matchLabels:
      app: expiration
  template:
    metadata:
      labels:
        app: expiration
    spec:
      containers:
        - name: expiration
          image: oscargm40/expiration-ticketing-k8s:latest
          imagePullPolicy: Always  
          env:
            - name: NATS_URL
              value: 'http://nats-srv:4222'
            - name: NATS_CLUSTER_ID
              value: ticketing
            - name: NATS_CLIENT_ID
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name 
            - name: REDIS_HOST
              value: 'expiration-redis-srv'

Para el Deploy+Service de Redis me vale el de Mongo pero con la imagen 'redis' y con las variables que necesite.Pan comido,asin.

					VIDEO 425 FILE SYNC SETUP

Aún me falta actualizar el skaffold.yaml con el nuevo microservicio:
    - image: oscargm40/expiration-ticketing-k8s
      context: expiration
      docker:
        dockerfile: Dockerfile
      sync:
        manual: 
          - src: 'src/**/*.js'
            dest: .
REinicio todo y compruebo que los servicios se conectan a sus DBs y a NATS.Todo perfecto,asinto

						VIDEO 426 LISTENER CREATION

Vamos a empezar creando el listener para el order:created. 

import { Listener, OrderCreatedEvent, Subjects } from '@oscargmk8s/common';
import { Message } from 'node-nats-streaming';
import { queueGroupName } from './queue-group-name';

export class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  readonly subject = Subjects.OrderCreated;
  queueGroupName = queueGroupName;

  async onMessage(data: OrderCreatedEvent['data'], msg: Message) {

  }
					
				VIDEO 427 WHAT'S BULL ALL ABOUT?

Normalmente se suele tener una request(por ejemplo,convertir un mp4 a mkv).En vez de simplemente ejecutar esa tarea inmediatamente,se suele tener un Worker Server,algo que se ocupa de esta tarea(y puedo tener varias copias de este servicio).
Cuando se hace esta petició se crea un job,que no es más que un plain object de JS,incluyendo las demandas que necesita para ese job.Este job se va a guardar en la Redis DB y las diferentes replicas del Worker Service van a estar haciendo pull a la DB en cuanto haya un job nuevo
Cuando lo completen informarán de nuevo.Bull JS se ocupa tanto de informar desde el Worker hacia Redis como cuando se crea el job y se guarda en Redis(ver imagen)
NOTA: puede parecer que Bull tiene cierta similitud con NATS ,pero no es asi,no es capaz de procesar una vasta cantidad de mensajes de forma asíncrona,está hecho para gestionar pequeñas tareas
Trabajaremos agregando un job a una queue(una serie o grupo de acciones).Asi que con Bull crearemos Queues y le agregamos un job 

						VIDEO 428 CREATING A QUEUE

Realmente es bastante sencillo crear estas Queues,simplemente hay que importar la clase desde la libreria al proyecto.Despues recibirá el nombre del 'canal' como primer argumento(aunque técnicamente no es un canal,es sólo el nombre del grupo) y como segundo argumento un objeto con las opciones de conexión:

import Queue  from "bull";

interface Payload {
   orderId: string;
}

const expirationQueue = new Queue<Payload>("order:expiration",{
   redis: {
      host: process.env.REDIS_HOST,
   }
})

// job is wrapping the payload,the data,which is orderId:'sfsf' 
expirationQueue.process(async (job) => {
   console.log("I want to publish an expiration:complete event for orderId", job.data.orderId);
});

export { expirationQueue };

Fijate que fácil he creado un tipado para una instancia de una clase pasandole una interfaz como genérico.Cuando tenga cualquier clase puedo pasarle una interfaz para tiparla(class<T>).Increible:
interfaz Casa {
  habitaciones:number;
  metros:number;
  }
class Edificio<Casa> <- cuando haga new Edificio TS me va a ayudar con el tipado.

				VIDEO 429 QUEUEING A JOB ON EVENT ARRIVAL

Recordemos que habiamos dejado el async onMessage(data,msg) sin lógica.Es aqui donde tenemos que ir ahora,pues es en la recepción del order:created cuando hay que hacer algo con Bull + Redis.Es muy sencillo:

 async onMessage(data: OrderCreatedEvent['data'], msg: Message) {
    await expirationQueue.add({
      orderId: data.id,
    });

    msg.ack();
  }
El método expirationQueue.add(data,options) lleva la data a agregar a la cola como primer argumento.El segundo no lo necesitamos.

Aun falta crear la instancia del listener en el index.ts:
 new OrderCreatedListener(natsWrapper.client).listen();

				VIDEO 430 TESTING JOB PROCESSING

Creo un ticket en Postman y despues una Order.Fijate que parece que no es event.version -1 en mi caso.Investigar más.

				VIDEO 431 DELAYING JOB PROCESSING

 Para poner un delay a la hora de agregar el job simplemente uso la propiedad delay como segundo argumento:
      // el tiempo desde el expiresAt hasta el actual
    const delay = new Date(data.expiresAt).getTime() - new Date().getTime();
    await expirationQueue.add({
      orderId: data.id,
    }, {
      delay: delay
    });

			VIDEO 432 DEFINING THE EXPIRATION COMPLETE EVENT

Hay que crear una nueva interfaz y su tipo en el common module:

import { Subjects } from './subjects';

export interface ExpirationCompleteEvent {
   subject: Subjects.ExpirationComplete;
   data: {
      orderId: string;
   };
}
Exporto este archivo en el index,hago una nueva publish y actualizo el expiration folder.

			VIDEO 433 PUBLISHING AN EVENT ON JOB PROCESSING

Creo la clase ExpirationCompletePublisher que hereda de la abstracta del video anterior y en el new Queue<Payload>,en el método process de la instancia llamamos a esta clase,que publicará el evento:

expirationQueue.process(async (job) => {
   new ExpirationCompletePublisher(natsWrapper.client).publish({
      orderId: job.data.orderId,
   });
Fijate que simplemente va a publicar un evento tras X tiempo toda esta lógica.

Hacemos una prueba.Fijate que ahora nos queda recibirlo en el Orders srv o cualquier srv que lo necesite.

				VIDEO 434 HANDLING AN EXPIRATION EVENT

Ahora que ya emitimos el expiration:complete en nuestro Expiration Srv el Orders srv debería marcar esa Order como cancelled.Al cancelarla tendremos que emitir elorder:cancelled también,pero vayamos por lo primero,que es crear un listener en el Orders para el expiration:complete event.

xport class ExpirationCompleteListener extends Listener<ExpirationCompleteEvent> {
   readonly subject = Subjects.ExpirationComplete;
   queueGroupName = queueGroupName;
   
   async onMessage(data: ExpirationCompleteEvent['data'], msg: Message) {
      const order = await Order.findById(data.orderId);
   
      if (!order) {
         throw new Error('Order not found');
      }
   
      if (order.status === OrderStatus.Complete) {
         return msg.ack();
      }
   
      order.set({
         status: OrderStatus.Cancelled,
      });
* Realmente aquí se nos presenta una duda.¿Ponemos el ticket a null dentro de la Order ,dado que se ha cancelado la orden?O lo mantenemos?

				VIDEO 435 EMITTING THE ORDER CANCELLED EVENT 

Poner a null el ticket es una mala idea.Perderemos la información.¿Y si queremos ver el ticket que estaba asociado a una Order aunque está fue cancelada?.

Además ya tengo un método estático en el modelo que me devuelve true o false,es decir, si esta reservado.Si la orden del ticket actual esta en estado Created,Awaiting o Complete devuelve que está reservado(bloqueando su edición,ya que simplemente se ha creado,es decir no hay una orden sobre él,o ya se ha pagado o alguién está intentando pagarlo).

TicketSchema.methods.isReserved = async function () {

   const existingOrder = await Order.findOne({
      ticket: this,
      status: {
         $in: [
            OrderStatus.Created,
            OrderStatus.AwaitingPayment,
            OrderStatus.Complete,
         ]
      }
   })
   return !!existingOrder;
}

Fijate que en cuanto la order se ponga en Cancelled el ticket se considerará NoReservado,desbloqueandolo para su edición,pues vuelve a estar libre.
Fijate que el order:cancelled le interesa al Payment srv,ya que no puede pagarse esa orden más,pues se canceló el pedido.

Asi pues simplemente emitimos el order:cancelled que ya tenemos la clase:

      order.set({
         status: OrderStatus.Cancelled,
      });

      await order.save();

      await new OrderCancelledPublisher(this.client).publish({
         id: order.id,
         version: order.version,
         ticket: {
            id: order.ticket.id,
         },
      });
   
      msg.ack();

IMPORTANTE: fijate en el uso del await new OrderCancelledPublisher ... para asegurarnos que no se llama antes al msg.ack();

		VIDEO 436 TESTING THE EXPIRATION COMPLETE LISTENER

Realmente es un punto crítico de la aplicación este evento,asi que vamos a realizar un par de tests sobre el evento.Como siempre empezamos por la función setup:


const setup = async () => {
   const listener = new ExpirationCompleteListener(natsWrapper.client);

   const ticket = Ticket.build({
      id: mongoose.Types.ObjectId().toHexString(),
      title: 'concert',
      price: 20,
   });

   await ticket.save();

   const order = Order.build({
      status: OrderStatus.Created,
      userId: 'asdf',
      expiresAt: new Date(),
      ticket,
   });

   await order.save();

   const data: ExpirationCompleteEvent['data'] = {
      orderId: order.id,
   };

   // @ts-ignore
   const msg: Message = {
      ack: jest.fn()
   };

   return { listener, order, ticket, data, msg };

}

				VIDEO 437 TESTING AFTER SETUP

Recuerda que hay que llamar a una función extra.Creo los tests:

test('updates the order status to cancelled', async () => {
  const { listener, data, msg, ticket,order} = await setup();
   //  me traigo el setup y llamo al onMessage
  await listener.onMessage(data, msg);
  // simplemente busco la orden y compruebo su status
  const updatedOrder = await Order.findById(order.id);

  expect(updatedOrder!.status).toEqual(OrderStatus.Cancelled);

});

it('emit an OrderCancelled event', async () => {
  const { listener, data, msg, ticket,order} = await setup();

   await listener.onMessage(data, msg);
   // debo esperar que se haya llamado al publish,no?
   expect(natsWrapper.client.publish).toHaveBeenCalled();
   // y que se haya llamado con el id exacto de la Order
   const eventData = JSON.parse((natsWrapper.client.publish as jest.Mock).mock.calls[0][1]);

   expect(eventData.id).toEqual(order.id);

});

Más sencillo de lo que parece,asin.

					VIDEO 438 LISTENING FOR EXPIRATION 

Aun nos falta ponernos a la escucha en el index.ts:
new TicketCreatedListener(natsWrapper.client).listen();
    new TicketUpdatedListener(natsWrapper.client).listen();
    new OrderCancelledListener(natsWrapper.client).listen();

Puedo testearlo en Postman,creando un ticket,despues una orden y debería ver el evento order:cancelled publicado por el Orders srv(pero primero por el Expiration srv).

						SECCION 21 THE PAYMENTS SRV

Recordemos que el payments srv va a estar escuchando por el order:created y el order:cancelled y él mismo va a emitir el charge:created para el Charge srv

					VIDEO 441 INITIAL SETUP

Este srv va a necesitar express,asi que copio según el video desde tickets srv.
Tendrá un MongoDb Service también,aparte de un par de rutas(asi que es otro igual que el tickets o el orders).
REconfiguro el scaffold.yaml y le creo el Deploy y Service para el NOde y la el Deploy+Srv para el Mongo.

					VIDEO 442 REPLICATED FIELDS

El payments srv va a estar escuchando por order:created y order:cancelled y emitirá el charge:created.
También tendrá dos colecciones,una que replicará la de Orders y otra Charge.Asi que resumiendo va a necesitar dos Listener,un publisher y dos Modelos.

Analicemos qué propiedades hay que replicar de una Order:
id: obviamente es lo más importante,debe estar replicada
status:también debe tener conocimiento del estado
version: otro campo fundamental
userId:de nuevo es fundamental saber que usuario debe pagar
expiresAt:realmente tenemos un Servicio que ya emitirá un evento,no es necesario,con la propiedad Status ya nos vale
ticket:{id,price}: ¿necesito el id o el precio?el id realmente no lo necesito,pero el precio sin lugar a dudas.
Resumen:{id,status,version,userId,price}

				VIDEO 443 ANOTHER ORDER MODEL!

Simplemente creamos el modelo:


// interfaz sólo para el tipado
interface OrderAttrs {
   id: string;
   version: number;
   userId: string;
   price: number;
   status: OrderStatus;
}
// en el doc no es necesario el id pues un documento va a tener uno
interface OrderDoc extends mongoose.Document {
   version: number;
   userId: string;
   price: number;
   status: OrderStatus;
}
// el Modelo es la Coleccion,no el documento,lógicamente build es de la coleccion
interface OrderModel extends mongoose.Model<OrderDoc> {
   build(attrs: OrderAttrs): OrderDoc;
}

const OrderSchema = new mongoose.Schema({
   userId: { type: String, required: true, },
   price: { type: Number, required: true, },
   status: { type: String, required: true, },
   // no meto la version porque lo va a gestionar el plugin
   }, {
   toJSON: {
      transform(doc, ret) {
         ret.id = ret._id;
         delete ret._id;
      },
   },
})

OrderSchema.set('versionKey','version');
OrderSchema.plugin(updateIfCurrentPlugin);

OrderSchema.statics.build = (attrs: OrderAttrs) => {

   return new Order({
      _id: attrs.id,
      version: attrs.version,
      price: attrs.price,
      userId: attrs.userId,
      status: attrs.status,
   })
}
 
const Order = mongoose.model<OrderDoc, OrderModel>('Order', OrderSchema);
export { Order };

Fijate que ha declarado status como un String en el Schema pero como una enum en las interfaces.

				VIDEO 445 REPLICATING ORDERS

De nuevo creamos un Listener:

port class OrderCreatedListener extends Listener<OrderCreatedEvent> {
  readonly subject = Subjects.OrderCreated;
  queueGroupName = queueGroupName;

  async onMessage(data: OrderCreatedEvent['data'], msg: Message) {
   // creamos el Order
   const order = Order.build({
      id: data.id,
      price: data.ticket.price,
      status: data.status,
      userId: data.userId,
      version: data.version,
   });
   // guardamos el Order
   await order.save();

   // aseguramos que el evento se recibió y procesó correctamente
   msg.ack();

  }

				VIDEO 446 QUICK TESTING

Hacemos un simple test comprobando que se emite la data correctamente:

it('replicates the order info', async () => {
   const { listener, data, msg } = await setup();

   await listener.onMessage(data, msg);
   // busco la order por el id
   const order = await Order.findById(data.id);
   // y comparo la propiedad emitida contra la original
   expect(order!.price).toEqual(data.ticket.price);
})

it('acks the message', async () => {
   const { listener, data, msg } = await setup();

   await listener.onMessage(data, msg);

   expect(msg.ack).toHaveBeenCalled();
})

Si data.ticket.price es el order.price está claro que emite el evento.

			VIDEO 447 MARKING AN ORDER AS CANCELLED

Creo el listener que cancele una orden al escuchar este evento:

export class OrderCancelledListener extends Listener<OrderCancelledEvent> {
   readonly subject = Subjects.OrderCancelled;
   queueGroupName = queueGroupName;

   async onMessage(data: OrderCancelledEvent['data'], msg: Message) {
      // realmente no haria falta la version,porque no va a haber problemas de concurrencia
      const order = await Order.findOne({
         _id: data.id,
         version: data.version - 1
      });

      if (!order) {
         throw new Error('Order not found');
      }

      order.set({ status: OrderStatus.Cancelled });
      await order.save();

      msg.ack();
   }
}
Si tubiera problemas con la version buscar por la última tras ordenar.

			VIDEO 448 CANCELLED TESTING

Esta vez creamos una Orden ya en el setup:

 const order = Order.build({
      id: mongoose.Types.ObjectId().toHexString(),
      status: OrderStatus.Created,
      price: 10,
      userId: 'asdf',
      version: 0
   })
   
   await order.save();
   
   const data: OrderCancelledEvent['data'] = {
      id: order.id,
      version: 1, //debe de ser una más que la version actual
      ticket: {
         id: mongoose.Types.ObjectId().toHexString()
      }
   }

   // @ts-ignore
   const msg: Message = {
      ack: jest.fn()
   }

   return { listener, data, msg, order };

}

it('updates the status of the order', async () => {
   const { listener, data, order, msg } = await setup();

   await listener.onMessage(data, msg);
   // busco la order por el id
   const updatedOrder = await Order.findById(order.id);
   // y compruebo su estatus,debe estar cancelada
   expect(updatedOrder!.status).toEqual(OrderStatus.Cancelled);
})

				VIDEO 449 STARTING THE LISTENERS

De nuevo implemento ambas clases en el index.ts y hago un pequeño test con Postman creando un ticket y despues una Order,confirmando que el Payments srv recibe el evento order:created

				VIDEO 450 PAYMENTS FLOW WITH STRIPE

Vamos a usar la libreria StripeJs que me permitirá abstraerme de trabajar con toda la seguridad que se necesita implementar al gestionar un pago con una tarjeta de crédito.
StripeJs me permitirá usar una ventana modal para mostrarle al cliente.
El flujo mas o menos es así:

1- El usuario rellena el modal y da en submit/enviar/pagar...
2- La data llega a la Stripe API,que devuelve un token hacia el cliente(debería ver este token como una especie de pre-autorización hacia mi).Me va a permitir pre-cargar en esa tarjeta cierta cantidad de dinero(aún no se ha completado el pago)
* Es un token de un sólo uso.

3- En el cliente,en el lenguaje que sea(en este caso js) vamos a coger este token y mandarlo al payments service(a un backend).

4- Nosotros miraremos que se esté intentando pagar una Order válida(no esté Canelled) y tras decidir que está todo correcto cargaremos esa cantidad al cliente,enviando de nuevo ese token a la Stripe API
Esto último creará un Charge(un pago)

NOTA: puede verse que hay una gran parte gestionada por el cliente(el cual aún no tenemos).Sin embargo podemos hacer la parte del backend ya y hacer pruebas con Postman simulando las peticiones de un cliente

			VIDEO 451 IMPLEMENTING THE CREATE CHARGE HANDLER

Vamos a implementar el paso 4 (creación de ese endpoint,recepción del token y envio a la Stripe API de ese mismo token).

Nuestro Payments Srv va a seguir una serie de reglas de validación tras recibir esa request:
NOTA: recibiremos {token:token,orderId:id}
1- Buscará una order con esa order Id
2- Se asegurará que esa order pertenece al user que la creó originalmente(mediante jwt.decode ??)
3- Se asegurará que el price a pagar es el mismo que el cargo a la tarjeta
4- Verificará el payment con Stripe API,reenviando ese token(es aqui donde se carga al usuario y se cobra el dinero creando un charge o cargo)
5- Creará un 'charge' record en la DB para grabar cada cargo que realicemos.

NOTA: recuerda que cualquier microservicio que use un Routing com express,Angular,React... debe ser configurado en el IngressNGINX del cluster.

   - path: /api/payments/?(.*)
            pathType: "Prefix" # investigar los tipos
            backend:
              # serviceName: auth-srv # OJO CON LAS VERSIONES!!
              # servicePort: 3000
              service:
                name: payments-srv
                port: 
                  number: 3000

Fijate que /api/payments/?(.*) <- la '?' indica opcional asi que puedo hacer peticiones a /api/payments o a /api/payments/cualquiercosa
Recuerda llevar cada router al app.ts para usar esa ruta.

IMPORTANTE: fijate como SG también usa la misma sintaxis que FH:
router.post('/api/payments',
   requireAuth,
   [
      body('token')
         .not()
         .isEmpty()
         .withMessage('Token is required'),
      body('orderId')
         .not()
         .isEmpty()
         .withMessage('OrderId is required'),
      body('orderId')
         .isMongoId()
         .withMessage('orderId field muste be a valid Id'),
   ],
   validateRequest,
   async (req: Request, res: Response) => {
      res.send({ success: true });
   })

export { router as createChargeRouter };
Debo usar lo mismo yo(ruta,validateTokenMW,[validators],validateFieldsMW,controller).Definitivamente parece el mejor approach.
Parece que puedo usar 'as' en los export e import(sólo hay??).
NOTA: recuerda que 2GB para k8s pueden ser pocos para este proyecto

			VIDEO 452 VALIDATING ORDER PAYMENT

Vamos a empezar con los primeros pasos de las validaciones de Payments Srv(que exista esa OrderId,que el user que la creo sea el mismo que el que quiere pagar y que el estado de la Order aún sea válido).
      const { token, orderId } = req.body;

      const order = await Order.findById(orderId);

      if (!order) {
         throw new NotFoundError();
      }
      // recuerda que requireAuth me deja hacer req.currentUser! porque si pasó requireAuth hay un req.currentUser fijo.
      if (order.userId !== req.currentUser!.id) {
         throw new NotAuthorizedError();
      }

      if(order.status === OrderStatus.Cancelled) {
         throw new BadRequestError('Order already cancelled.Cannot pay for an cancelled Payment Order');
      }

      res.send({sucess: true});
Vamos a testear estas tres situaciones,ya que son casos muy importantes.Usaremos un id no válido,despues crearemos dos users y trataremos de pagar la order de otro y despues crearemos una order y esperaremos simplemente que se cancele y trataremos de pagar.
Ninguna de estas acciones debería ser realizable.

			VIDEO 453 TESTING ORDER VALIDATION BEFORE PAYMENT

Vamos a testear la ruta,ya que es importante:
  
it('should returns a 404 when purchasing an order that does not exists', async () => {

    await request(app)
      .post('/api/payments')
      // @ts-ignore
      .set('Cookie', global.signin())
      .send({
        token: 'askldjfsljdf',
        orderId: mongoose.Types.ObjectId().toHexString(),
      })
      .expect(404);
  })

Para el segundo test creo una order y trato de guardarla con otro user.No deberia dejarme(401)
  it('returns a 401 when purchasing an order that doesn\'t belong to the user', async () => {

    const order = Order.build({
      id: mongoose.Types.ObjectId().toHexString(),
      userId: mongoose.Types.ObjectId().toHexString(),
      version: 0,
      price: 20,
      status: OrderStatus .Created,
    });

    await order.save();

    await request(app)
      .post('/api/payments')
      // @ts-ignore
      .set('Cookie', global.signin())
      .send({
        token: 'askldjfsljdf',
        orderId: order.id,
      })
      .expect(401);
  })

				VIDEO 454 TESTING SAME-USER VALIDATION

El último test será asegurarse que recibo un 400 al tratar de pagar una CancelledOrder.Vamos a tener un par de problemas para poder simular esto:

 if (order.userId !== req.currentUser!.id) {
         throw new NotAuthorizedError();
      }  

Porqué?Porque nuestro global.signin(),tal como lo tenemos,crea un id aleatorio:

global.signin = () => {
   // Build a JWT payload { id, email}
   const payload = {
      id: new mongoose.Types.ObjectId().toHexString(),
      email: 'test@test.com',
   }
Asi que vamos a hacer que pueda recibir un ARGUMENTO OPCIONAL,que será el id:
  global.signin(id?:string) => {
    const payload = {
    id: id || new mongoose....

NOTA:recuerda que debo marcar el argumento como opcional con ? y que puedo evaluar con || si es null o undefined,asinto.

  it('returns a 400 when purchasing an cancelled order', async () => {
    const userId = new mongoose.Types.ObjectId().toHexString();

    const order = Order.build({
      id: mongoose.Types.ObjectId().toHexString(),
      userId,
      version: 0,
      price: 20,
      status: OrderStatus.Cancelled,
    });
    
    await order.save();

    await request(app)
      .post('/api/payments')
      // @ts-ignore
      .set('Cookie', global.signin(userId))
      .send({
        token: 'askldjfsljdf',
        orderId: order.id,
      })
      .expect(400);

Como siempre testeo lo contrario también.

						VIDEO 455 STRIPE SETUP

En orden de poder comunicarnos con la Stripe API vamos a tener que instalar el SDK de Stripe para Node(una simple libreria npm que me permitirá comunicarme con su backend).
Cuando intente comunicarme con su API para cobrar a un usuario tengo que proporcionar un token y una API key que identifique mi aplicación.
Asi que hay que hacer dos pasos,instalar el SDK y registrarme en su web para que me den una API key

PASO UNO
>npm i stripe <- el SDK es muy ligero,esto lo instala
PASO DOS
voy a https://stripe.com y me registro(aunque la web pueda cambiar su API apenas cambia y es muy estable)
Alli al registrarme ya me dan una clave pública y privada,y si ya lo estoy en developers,api keys puedo ver la key privada.

			VIDEO 456 CREATING A STRIPE SECRET

Recuerda que tengo la app en un cluster de Kubernetes,asi que puedo crear un secret en el cluster:
Sintaxis: k create secret generic nombreDelSecret --from-literal STRIPE_KEY=sk_test_sdfsdf
>kubectl create secret generic stripe-secret --from-literal ...

Si ahora muestro los secrets de mi cluster veré que lo he creado de tipo opaque:
 get secret
NAME                  TYPE                                  DATA   AGE
default-token-6njkg   kubernetes.io/service-account-token   3      168d
jwt-secret            Opaque                                1      104d
postgres-secret       Opaque                                1      159d
stripe-secret         Opaque                                1      5s

Como lo voy a usar en el pod aún tengo que ir al Deploy y decirselo a k8s.
       - name: STRIPE_KEY # secret del cluster para stripe
              valueFrom:
                secretKeyRef:
                  name: stripe-secret
                  key: STRIPE_KEY

El name va a ser como lo llamaremos en el cluster,más concretamente en este servicio,pues sólo lo declaré aquí.Hace referencia al secret con el nombre 'stripe-secret' y la key STRIPE_KEY.El value será inferido.
Y todo esto lo ha encriptado?

					VIDEO 457 CREATING A CHARGE WITH STRIPE

 Para poder usar stripe hay que crear una instancia de la clase Stripe.Vamos a crear un único file para crear una instancia única:

En stripe.ts:
import Stripe from 'stripe';

export const stripe = new Stripe(
  process.env.STRIPE_KEY!, {
    apiVersion: '2020-08-27', // usar la que me sugiera stripe
});
Fijate que fácil es crear un singleton en ts o js.

Para poder cobrar hay que crear un charge y para crear este charge lo puedo ver en la doc oficial pero es con el método create de la propiedad charges,y fijate que es una Promise.Habrá métodos para crear un charge,para borrarlo,actualizarlo...

await stripe.charges.create({
  amount:2000,
  currency:'usd'
  source:
  description:

Algunas propiedades son requeridas(amount,currency y source lo son).Stripe siempre usa la 'smallest currency unit',es decir céntimos de euro o de dollar,etc.(luego ese 2000 son 20 dolares americanos).
El source es a donde cargar el dinero.Puede ser el id de una credit car,un bank account,un token,.. Lógicamente tampoco es un field opcional.
La description es opcional.

Con esto en mente creamos este charge en el controller.
   await stripe.charges.create({
         currency: 'usd',
         amount: order.price * 100,
         source: token,
         description: 'Charge for orderId: ${orderId}',
      });

				VIDEO 458 MANUAL TESTING OF A CHARGE

Para testear un pago habrá que crear un ticket,despues una Order con ese ticket y despues una petición a /api/payments(el único endpoint de momento).
Si bien tenemos que recuperar un token del body mientras estemos en modo prueba en stripe tenemos un token disponible(tok_visa).Siempre va a funcionar:

* Hay que mandar a /api/payments una orderId:
{
    "orderId":"",
    "token":"tok_visa"
}
En cuanto mande una orderId válida durante el tiempo estipulado debería ser capaz de crear un pago en stripe.

					VIDEO 459 AUTOMATED PAYMENT TESTING

IMPORTANTE: recuerda que los secrets como la private key de stripe que tengo en el cluster sólo están accesibles dentro de ese cluster,pero el ambiente de pruebas se ejecuta en mi máquina local,fuera de minikube y el cluster.
Es por esto que no tengo acceso a esta variable de entorno.ASi que tengo dos opciones:
1ª: crear otra variable de entorno en mi SO
2ª: hacer un mock de stripe(tal como hicimos en el folder __mocks__ con natsWrapper.ts).Puedo hacer un mock del file stripe.ts alli.

NOTA:voy a simular un objeto llamado 'stripe' con un método  create que resolverá a un objeto:
export const stripe = {
  charges: {
    create: jest.fn().mockResolvedValue({  }),
  }
}

				VIDEO 460 MOCKED STRIPE CLIENT

Recuerda que para usar este objeto como mock tengo que traerlo de donde está originalmente,no se trata de traer el de aquí:
* Me traigo el original
import { stripe } from '../../stripe';
* Y lo simulo,si hay un mock jest usará ese mock
jest.mock('../../stripe');
NOTA:fijate que siempre me refiero a la ruta del original,pero se usará el fake.Jest mirará en ese folder __mocks__ y si lo encuentra usará ese al 100% seguridad



  it('returns a 201 with valid inputs',async () => {
    const userId = new mongoose.Types.ObjectId().toHexString();

    const order = Order.build({
      id: mongoose.Types.ObjectId().toHexString(),
      userId,
      version: 0,
      price: 20,
      status: OrderStatus.Created,
    });
    
    await order.save();

    await request(app)
      .post('/api/payments')
      // @ts-ignore
      .set('Cookie', global.signin(userId))
      .send({
        token: 'tok_visa',
        orderId: order.id,
      })
      .expect(201);

    const chargeOptions = (stripe.charges.create as jest.Mock).mock.calls[0][0];
    expect(chargeOptions.source).toEqual('tok_visa');
    expect(chargeOptions.amount).toEqual(20 * 100);
    expect(chargeOptions.currency).toEqual('usd');


  })
Fijate que no tuve que hacer el JSON.parse y que realmente no estoy probando nada contra la stripe API.

				VIDEO 461 A MORE REALISTIC TEST SETUP

La opción dos es usar la API y crear un cargo de forma normal.Son opciones excluyentes,o uso una o uso otra.
Asi que renombro el file anterior a stripe.ts.old en el folder __mocks__ para que no sea cargado por jest y remuevo el jest.mock hacia el archivo original del test.
En el setup.ts creo la environmet con la api key private.Sin embargo,testearlo va a ser un tanto complejo,pues necesitamos acceder a la respuesta que nos proporcione su APi en el ambiente de test,y ¿como hacemos esto?.
Podríamos cambiar el controlador para acceder a estos datos,pero nunca se debe cambiar el código existente para pasar una prueba.

Stephen lo arregla yendo a la documentación oficial y alli vemos que también hay formas para obtener(retrieve) un charge,para listar los últimos 10,...

NOTA:fijate que hay create | retrieve | update | capture | list all charge
Desafortunadamente retrieve necesita un chargeId y no lo tenemos,pero si podemos listar los últimos 10 cargos.
Desafortunadamente también parece que viene desordenada,asi que mandaremos algo único(mandaremos un precio generado random).Despues desde el ambiente de test haremos la petición a esa ruta de la stripe API y comprobaremos si en los últimos diez hay un cargo con esa cantidad

					VIDEO 462 REALISTIC TEST IMPLEMENTATION

Con todo lo anterior en mente creamos un price random:

 const price = Math.floor(Math.random() * 100000);

    const order = Order.build({
      id: mongoose.Types.ObjectId().toHexString(),
      userId,
      version: 0,
      price,
      status: OrderStatus.Created,
    });

Y despues buscamos en los últimos 50(mejor usar más para reducir las posibilidades de que no esté este cargo)

   const stripeCharges = await stripe.charges.list({ limit: 50 });
      const stripeCharge = stripeCharges.data.find(charge => {
        return charge.amount === price * 100;
      });

      expect(stripeCharge).toBeDefined();

NOTA:stripes.charges.list devuelve un objeto con la data en su propiedad del mismo nombre 'data'.
