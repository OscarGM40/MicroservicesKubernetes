								VIDEO 383 REMINDER ON VERSIONING RECORDS

Desde ahora el Tickets Srv va a usar otro field llamado 'version'.Lo emitirá también al publicar,informando así del orden cardinal de ese ticket.
Cada vez que se haga una operació adicional en un mismo ticket se aumentará el número de versió.
El Orders Srv va a mirar atentamente por este campo,de modo que si le viniera un ticket:updated con 15$ y version 3 pero en la DB la última grabación es la 1 no lo va a procesar.
Esto lo hacemos no llamado al metodo message.ack()(en realidad lo llamaremos condicionalmente desde ahora).
El evento volverá al NATS y será emitido al de 5seg de nuevo(lo bajamos de 30).
NOTA:para evitar eventos que rebotan indefinidamente en un servidor se puede implementar lógica,por ejemplo,con el numero de veces que ha rebotado,si es + de una cantidad x que se borre el evento.

Tanto mongoose como MongoDb pueden manejar este incremento de versión automáticamente,asi que no es algo difícil(un campo autoincremental)

				VIDEO 384 OPTIMISTIC CONCURRENCY CONTROL

Esta estrategia es agnóstica al gestor de DB,puedo usar SQL perfectamente con un versioning system.
Lo que se hará es buscar tanto por Id como por versión con el ORM,así no hay posibilidad de fallo.Una vez encontrado se procesa la operación y el gestor DB autoincrementa el campo.
Esto es el camino feliz,pero imaginemos que perdemos el updated a 10$(el dos) y nos llega el tres.Querremos buscar por un ticket con id 'xxx' y version de 2,pero cmo se perdió solo encontraremos la versión 1.

					VIDEO 385 MONGOOSE UPDATE-IF-CURRENT

Vamos a seguir el flujo de la app.Primero cambiaremos la DB del Tickets Srv,despues el modo de publicar que tiene y por último la recepción del evento y posterior guardado en el Orders Srv.

Vamos a usar un módulo que ayude a mongoose en esto(fijate que es para mongoose 5+).
El módulo está aqui:
https://www.npmjs.com/package/mongoose-update-if-current

Es un Optimistic concurrency control plugin for Mongoose v5.0 and higher,se importa el plugin desde el módulo y se añade o bien en global o a un determinado schema(a la instancia de mongoose o a la instancia del schema):

import { updateIfCurrentPlugin } from 'mongoose-update-if-current';
mongoose.plugin(updateIfCurrentPlugin) <- en global para todos los schemas
mySchema.plugin(updateIfCurrentPlugin) <- sólo ese schema

* Puede usar o el versionKey o el timestamp para incrementar la versión,el comportamiento por defecto será el __v,si quiero usar los timestamps tengo que habilitarlos y especificarlo en un segundo argumento que es un objeto:

mongoose.plugin(updateIfCurrentPlugin,{strategy:'timestamp'})

const mySchema = new mongoose.Schema({ ... }, { timestamps: true });
mySchema.plugin(updateIfCurrentPlugin, { strategy: 'timestamp' });

NOTA:fijate que el campo __v realmente nació para control de versiones,pues empieza en __v:0,pero lo vamos a renombrar a 'version' por legibilidad.

					VIDEO 386 IMPLEMENTING OOC

Con lo anterior en mente procedemos a instalar el módulo en el srv Tickets.Dado que vamos a renombrar el campo __v a version hay que especificarlo en la interfaz TicketDoc(que hereda de Document y dictamina que propiedades tiene una instancia de la DB,no la confundas con TicketAttrs que es una interfaz normal para el tipado):

// Interfaz que designa las propiedade requeridas para crear un nuevo Ticket.Es una simple interfaz para el tipado
interface TicketAttrs {
   title: string;
   price: number;
   userId: string;
}

// Interfaz que describe las propiedades que tendrá un Ticket una vez en la BBDD.Hereda de Document
interface TicketDoc extends Document {
   title: string;
   price: number;
   userId: string;
   version: number;
}

Dado que hay un bug que se resuelve en Mongoose 6+ tengo que usar ts-ignore:
ticketSchema.set('versionKey', 'version');
// @ts-ignore
ticketSchema.plugin(updateIfCurrentPlugin);

Fijate como con schema.set('oldProp','newName') podria renombrar propiedades. 

					VIDEO 388 TESTING OOC

Las nuevas versiones de jest no dejarán usar done() y return.O devuelvo la Promise o uso la callback.Con el return de la Promise me valdrá:

it('implements Optimistic Concurrency Control or OOC', async () => {
   // create an instance of a ticket
   const ticket = Ticket.build({
      title: 'concert',
      price: 5,
      userId: '123'
   });

   // save the ticket to the database
   await ticket.save();

   // fetch the ticket twice, es solo buscarlo,asin
   const firstInstance = await Ticket.findById(ticket.id);
   const secondInstance = await Ticket.findById(ticket.id);

   // make two separate changes to the tickets we fetched
   firstInstance!.set({ price: 10 });
   secondInstance!.set({ price: 15 });

   // save the first fetched ticket
   await firstInstance!.save();

   // save the second fetched ticket and expect an error
   try {
      await secondInstance!.save();

   } catch (err) {
      return;
   }
   // forma dos
   await expect(secondInstance!.save()).rejects.toThrow();

   throw new Error('Should not reach this point');
});

Fijate que ahora ya se puede hacer un await expect si es una Promise:
await expect(secondInstance!.save()).rejects.toThrow(); <- espero que esa promesa falle.Interesante.

					VIDEO 389 ONE MORE TEST

Actualmente no estamos testeando que el numero del campo version realmente incremente en uno.

   const ticket = Ticket.build({
      title: 'concert',
      price: 20,
      userId: '123'
   });

   await ticket.save();
   expect(ticket.version).toEqual(0);
   await ticket.save();
   expect(ticket.version).toEqual(1);
   await ticket.save();
   expect(ticket.version).toEqual(1); 

Puedo incluso cambiar alguno y ver que lo incrementará el sólo
Expected: 1
Received: 2

Ahora que ya tenemos implementada la OCC iremos al common module y agregaremos este campo 'field' en todos los eventos.

				VIDEO 390 WHO UPDATES VERSIONS?

¿Quien debe usar las versiones?Solo el  servicio PRINCIPAL responsable de grabar cualquier acción create/update/destroy debe emitir la versión también.NO los que lo reciban.Por ejemplo,en la primera app teniamos el Comment Srv,el Moderation Srv y el Query Srv,pues bien,sólo el Comment Srv puede cambiar la versión,ya que si recordamos el fluo primero se creaba un Comment,se Moderaba y despues iba al Query Srv que lo almacenaba.
Imaginate que el ModerationSrv también cambia la versión al moderarlo,esto no irá así en Microservicios,sólo habrá un Servicio responsable de versionar.En nuestro caso será Tickets srv,pero incluso si llama a otros que realicen alguna operación auxiliar,seguirá siendo él,el Tickets Srv,el que maneje las versiones(puede realizar un cambio tras recibir el Ticket tras esa operación auxiliar,pero será él y no ese servicio auxiliar).
En resumen debe estar centralizada en el srv principal la lógica del versionamiento.
NOTA:estos otros servicios auxiliares si que pueden incluir el campo 'version',pero no podrán cambiarlo.

Con todo esto en mente cambio las 4 clases del common module y le agrego el field version:number.Actualizo la dependencia en los srv Orders y Tickets.

				VIDEO 392 UPDATING TICKETS EVENT DEFINITIONS

Donde emitamos un evento le agrego version: ticket.version y ejecuto de nuevo la suite de tests.En el Tickets Srv no habrá problemas pero en el Orders hay varias cosas que hacer,pues ni siquiera tenemos esta propiedad en el Schema.
Fijate que hemos dejado la DB y la publicación por parte del Tickets srv bien,pero el orders va a tener bastante trabajo.

				VIDEO 394 APPLYING A VERSION QUERY

Vamos a instalar el plugin para Optimistic Concurrency Control en el Orders Srv:
npm i mongoose-update-if-current
Lo vamos a conectar al Schema Ticket,no al Order.
import { updateIfCurrentPlugin } from "mongoose-update-if-current"

TicketSchema.set('versionkey','version');
TicketSchema.plugin(updateIfCurrentPlugin);

Vayamos por los Listeners,tienen que recibir esta propiedad.También recuerda que no vamos a buscar por id más,sino por el id + version-1:

 // const ticket = await Ticket.findById(data.id); <- ya no será así

      const ticket = await  Ticket.findOne({ 
         _id: data.id,
         version: data.version - 1
      })

Despues de encontrar o no ese ticket le cambiaremos el price y/o title y lo guardaremos:
  const { title, price } = data;
      ticket.set({ title, price });
      await ticket.save();
NOTA: es cuando hagamos ese await ticket.save() cuando se incrementará el número de version,ya que acabamos de conectar el plugin a este ticketSchema también,asi que lo hará mongoose por nosotros.

Nos logeamos y creamos y actualizamos un ticket con Postman.Puedo ver que la version es guardada e incrementada por el Tickets srv,y que el Orders recibe el evento.

					VIDEO 395 DID IT WORK?

Vamos a realizar el mismo test que antes,creando un ticket,actualizando su price a 10$ y despues a 15$.Esta vez esperamos que el await Ticket.findOne({ _id:data.id,version:data.version -1}) falle en su busqueda y arroje el throw new Error().
Al suceder esto no se llamara al msg.ack() y NATS lo re-emitirá al de 5s.
Además que pararán los logs unos segundos puedo apreciar los Errores por consola,y como despues se re-emiten.
Por último Stephen ejecutó db.tickets.find({price:15}).length() en ambos y tiene 400,no se ha perdido ni uno,asinto.

NOTA: hay gente que se le está cerrando NATS por ese throw new Error:

NATS closing connection when throwing an error
2 votos
Martin · Clase 395 · hace 11 meses
I'm noticing that if I throw an error inside of my listener it's actually closing the NATS connection alltogether rather than simply not ackgnowledging the message.

For now I've switched to

if (!ticket)
      return console.log(`Ticket version ${version} coming in out of order`)

ratehr than throwing an error and it's working as expected now... Any ideas why it's behaving this way? Obviously it's not ideal if NATS is closing the connection any time a listener errors!

Cambiar a un return ... si me sucede 

					VIDEO ABSTRACTED QUERY METHOD

Realmente a Stephen no le gusta la sintaxis de la query con el findOne,asi que vamos a crear un nuevo método en el modelo Ticket cual prehistorics. 
NOTA:fijate en este nuevo conocimiento,puedo pasar a un argumento que sea un objeto con ciertas propiedades:

interface TickeModel extends mongoose.Model<TicketDoc> {
  build(attrs:TicketAttrs):TicketDoc
  findByEvent(event:{id:string,version:number}):Promise<Ticketdoc | null> <- null porque puede que no lo encuentre(es lo que devolverá findOne)

* el argumento event debe ser un objeto con las propiedades id y version
Realmente ese argumento event podría tener más propiedades,pero tienen que tener id y version fijo.Con esto en mente puedo crear un método estático:
TicketSchema.statics.findByEvent = (event:{id:string,version:number}) => {
  return Ticket.findOne({
    _id: event.id,
    version: event.version - 1,
  }) }

Ahora ya es sustituir,asin:
const ticket = await Ticket.findByEvent(data) ;
Hacemos una nueva prueba con postman y veo que todo funciona igual.Fijate lo fácil que es crear método estáticos o de instancia en un Model,etc...

			VIDEO 397 OPTIONAL VIDEO - VERSION WITHOUT UPDATE IF CURRENT





