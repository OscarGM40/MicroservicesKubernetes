					BASICS OF TYPESCRIPT

						VIDEO 568 OVERVIEW

El mayor objetivo de Typescript es ver los errores en el editor,antes de que se compile el TS a JS..Simplemente intenta tipar el Javascript.

1- TS intenta cogerr los errores durante desarrollo(sólo vale durante desarrollo)
2- Usa 'type annotations' para analizar mi código
3- De nuevo,sólo está activo durante desarrollo(esta sintaxis extra nunca llegará al navegador)
4- El compilado realmente no agrega ningun beneficio(a diferencia de Java u otros lenguajes compilados)

Hay webs como https://www.typescriptlang.org/play/ donde ver a qué Javascript me va a compilar el Typescript.Lo mejor es pensar en TS como un amigo

				VIDEO 569 ENVIRONMENT SETUP

Puedo instalar typescript de forma global(ts-node es una herramienta cli para terminal que combina los comandos ts y node)
NOTA: el compilador(tsc) viene  en el modulo typescript
>npm i -g typescript ts-node

* Puedo comprobar la instalación viendo la versión:
>tsc --help
>npm -g ls 
>ts-node --version
NOTA:fijate que puedo instalar VSCode al path desde settings y tipeando 'install path'.Ya lo hace él.Se recomienda instalar Prettier.
También es buena idea ir a Preferences y activar Format On Save.

						VIDEO 570 FIRST APP

Recuerda que el principal objetivo es que TS me ayude a ver los errores ANTES de ejecutar la aplicación en vez de después.

Para compilar un archivo en TS hay que usar tsc fileName.Esto creará su réplica en un .js:
>tsc index.ts <- generará el .js.

Ahora ya podría ejecutar el .js con node:
>node index.js

Claro que tener que hacer esto todo el rato es una mala idea.Para juntar las funcionalidades de compilar con tsc y ejecutar con node está el módulo ts-node(el cual instalamos anteriormente).
Lógicamente recibe el archivo TYPESCRIPT:
>ts-node index.ts
En un sólo paso puedo compilar el ts y ejecutar el js.

					CATCHING ERRORS WIHT TS

Podriamos tratar de imprimir proiedades que no existen:

 console.log(`
   The Todo with ID: ${ID} 
   Has a title of: ${title}
   Is it finished? ${finished}
   `)

   The Todo with ID: undefined 
   Has a title of: undefined
   Is it finished? undefined

Esto sucede al trabajar con Javascript.Pero TS me va a ayudar con estos errores,para que no los tenga.
Sabiendo que realmente las propiedades son completed(y no finished),id(en minúsculas) y title(también en minúsculas) debería tipar la respuesta

interface Todo {
   id: number;
   title: string;
   completed: boolean;
}

axios.get<Todo>(url).then(response => {
   const todo = response.data;
   const ID = todo.id;
   const title = todo.title;
   const finished = todo.completed;

NOTA: las interfaces en TS se usan para definir la estructura de un objeto.Asi pues,habrá un objeto por ahí en mi app de tipo Todo con las props id,title y completed.

Fijate que podia haber casteado la response.data como un Todo(pues es una instancia):

axios.get(url).then(response => {
   const todo = response.data as Todo;

Quizás tipar la respuesta sería mejor opción en este caso,pero debo memorizar que puedo inferir cualquier propiedad con un tipado casteandola(instance as interfaceName).Interesante.
Ya puedo ejecutar el archivo y no debería ver los undefined anteriores.
Fijate que estoy cogiendo el error antes de la ejecución y no después.Esto es una clara muestra de que he cogido y evitado un error antes de la ejecución(y es el mero propósito de la razón de ser de TS).

Bien,y que sucederá si sacamos todo esto a una función y le paso los argumentos en cualquier orden?:

   logTodo(ID,finished,title);
})

const logTodo = (id,title,completed) => {
   console.log(`
   The Todo with ID: ${id} 
   Has a title of: ${title}
   Is it finished? ${completed}
   `)
}
Esto actualmente ya da un error.De todas formas,de nuevo comprobamos que no vemos el error hasta que ejecutamos el programa.Es aqui donde entran las 'type annotations'.En cuanto ponga un tipo a los argumentos ya no podré pasar un orden cualquiera:

   logTodo(ID,finished,title);
})

const logTodo = (id:number,title:string,finished:boolean)
Esto me dará un error ya antes de ejecutar el script,pues no puedo pasar un boleano cuando espera un string.

				VIDEO 575 OVERVIEW OF THE COURSE

El objetivo de este minicurso es entender la sintax+features y despues centrarnos en la implementación(design patterns) mediante aplicaciones didacticas(última sección 7).Asi que primero habrá conceptos teóricos.
El orden de la teoria será:

1- Understanding basic types
2- Function typing + annotations
3- Type definition files
4- Arrays in TS
5- Modules systems
6- Classes + Refresher on OOP
7- Projects( design patterns)

						VIDEO 576 TYPES 

En TS casi cualquier cosa que pueda tener un valor tiene un tipo.Una función tendrá su tipo,un array también,un objeto,una clase,...
IMPORTANTE: tipar una variable,objeto,array,.. no se hace sin ningun motivo.Si el lenguaje sabe de que tipo es cierto valor,sabrá que métodos puedo usar,qué propiedades,etc...Dar un tipado es muy importante.
Ejemplo: si red es un string el lenguaje sabré que puedo usar charAt,concat(),includes,endsWith,startsWith,indexOf,,localeCompare,match(),... y muchos métodos más prebuilt por el lenguaje solo por decir que la variable es de tipo string.
Como atajo a decir que la variable puede usar todos esos métodos lo que se hace es darle un simple y único nombre,en este caso 'string'.
Puedo ver un tipo como una etiqueta para identificar a qué métodos y propiedades tengo acceso

					VIDEO 577 MORE ON TYPES

En TS está el tipo Number,que en otros lenguajes suele subdividirse en varios,en este caso engloba cualquier tipo de numero.
En TS también está el tipo Date,por ejemplo.Veamos todos ellos:

Primitive: number,boolean,void,undefined,string,symbol,null
Object Types: function,array,class,object

Los types de TS se dividen en estas dos categorías,básicamente.
El tipado tiene dos grandes propósitos:
1- Ayudar a TS a que identifique los errore y me ayude
2- Ayudar a otros desarrolladores a que entiendan el código

Cada valor que declare en Typescript debe tener un tipo.

				VIDEO 579 FEATURE ONE - TYPING

Se debe tipar todo.Ejemplo:
const today = new Date(); <- TS me sugeriŕá métodos para una Date
Es por esto que se debe tipar todo.

		VIDEO 580 FEATURE TWO TYPE ANNOTATIONS + TYPE INFERENCE

Una type annotation es una pequeña pieza de código para decirle a TS de que tipo es una variable(:type)

Type inference: TS va a intentar averigüar por él mismo de qué tipo es una variable

Si bien parecen lo mismo en la primera soy yo el que le dice a TS el tipo,en la segunda lo averigüa TS por sí sólo.

// la sintaxis para una type annotation es :type
let apples: number = 5; //:number es la type annotation
// en cuanto anote a apples como number ya no podré pasarle como valor nada más que un number

let speed:string = "fast"; //:string es la type annotation
//de nuevo no podré reasignarla más que a otro string

let hasName: boolean = true; //:boolean es la type annotation

let nothingMuch: null = null; //:null es la type annotation
//este es el primer type annotation que coincide con su valor

let nothing:undefined = null; //:undefined es la type annotation
//este es el segundo type annotation que coincide con su valor

let now: Date = new Date(); //:Date es la type annotation

				VIDEO 581 OBJECT LITERAL ANNOTATIONS

Realmente ya śe todo esto,excepto el último(fijate que lo usé en event:{prop:type;prop:type}

/* Built in objects */
let now: Date = new Date(); //:Date es la type annotation
let colors: string[] = ["red", "green", "blue"]; 
let myNumbers: number[] = [1, 2, 3]; 
let truths:boolean[] = [true, false, true]; 

// Classes(siempre Capitalizadas)
class Car {}
let car: Car = new Car();
// Object literal
let point:{x:number; y:number} = { x: 10, y: 20 };
No confundir el type(que usa punto y coma) en la declaración con la inicialización del object(asignación de valores).

Las mismas reglas se aplican para estos tipos.NO podré asignar un valor que no coincida con estas type annotations de la izquierda:

let point:{x:number;y:number} <- point va a ser un object que tenga las props x e y,y me dará error si no las tiene,y serán number ambas.

				VIDEO 583 FUNCTION TYPE ANNOTATIONS

La type annotation para una función es un tanto compleja:
/* Function fijate en :(args) => return*/
const logNumber: (i:number) => void = (i: number) => {
   console.log(i);
   };
Fijate que lo que está a la izquierda del '=' siempre es el type annotation,da igual que sea una funcion,una clase,un object,...Lo de la izquierda es el tipo.

					VIDEO 584 TYPE INFERENCE

Si voy al archivo y borro todas las type annotations veré que no tengo error:
const apple=5; <- veré que es de tipo number.
const texto='hola'; <- veré que es de tipo string

NOTA: esto es el sistema de inferencia de tipos de TS.Pero,¿cuando puedo dejar a TS que infiera el tipo sin riesgo alguno?
Si hago la declaración e inicialización(asignación de valor/es) en la misma linea TS va a saber inferir el tipo correctamente(con lo que acabo de escribir medio file gratis -_-, mira que es prehistoric este TS).

NOTA: si TS no es capaz de inferirle el tipo porque separo la declaración e inicialización o es un tipo que no sabe inferir(como Color[]) siempre le va a poner de tipo 'any'.
Bien,entonces,¿si TS es capaz de inferir correctamente los types,cuando debo ser yo el que lo haga?Esto es una gran pregunta y hay una respuesta para ella:
1- cuando separe declaración e inicialización debo usar las types annotations yo o TS no sabrá qué es.
2- Cuando quiera usar un type que no puede ser inferido
3- Cuando una función devuelva 'any' y yo quiera ser más especifico.
Estos son los tres escenarios en los que tengo que tipar yo.El resto lo puede hacer TS.

					VIDEO 585 THE ANY TYPE

El tipo 'any' básicamente significa que Typescript no tiene ni idea que tipo de valor está siendo retornado(o asignado),asi que puede ser cualquiera.
La funcion JSON.parse() devuelve any,ya que puedo estar parseando cualquier cosa.Fijate que esto es el punto 3 que acabamos de comentar

IMPORTANTE: any es otro tipo más.Si algo es de tipo any TS no va a tener ni idea de que funciones,propiedades puede usar(adiós a los beneficios de un lenguaje tipado).HAY QUE EVITAR EL USO DE ANY A TODA COSTA.
La verdadera finalidad de tipar es encontrar errores antes de ejecutar el script,si usamos any TS no va a poder ayudar.

				VIDEO 586 FIXING THE ANY TYPE

En el ejemplo que teniamos,dado que JSON.parse devuelve any,aunque estemos en la misma linea tendré que ayudar a TS:

/* WHEN TO USE ANNOTATIONS BY ME */
// 1) Function that returns the 'any' type
const json = '{"x": 10, "y": 20}';
const coordinates:{ x:number; y:number } = JSON.parse(json);
console.log(coordinates); // {x: 10, y: 20}

				VIDEO 587 DELAYED INITIALIZATION

Siempre que use la inicialización en otra linea TS me va a tipar con 'any'.(fijate que veré tres puntitos sobre el warning).Este es un caso tonto pero muy explicito de que tengo que tipar foundWord con foundWord:boolean.

// 2) When we declare a variable on one line and initialize it later
let words = ["red", "green", "blue"];//aqui si infiere
let foundWord; //<- aqui no infiere

for (let i = 0; i < words.length; i++) {
    if (words[i] === "green") {
       foundWord = true; //es aqui donde la inicio
    }
}
La solución es darle el tipo en la declaración:
let foundWord:boolean;
* Fijate que asi se quita el warning y como TS me avisa.

				VIDEO 588 WHEN INFERENCE DOESN'T WORK


