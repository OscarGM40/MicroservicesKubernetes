					BASICS OF TYPESCRIPT

						VIDEO 568 OVERVIEW

El mayor objetivo de Typescript es ver los errores en el editor,antes de que se compile el TS a JS..Simplemente intenta tipar el Javascript.

1- TS intenta cogerr los errores durante desarrollo(sólo vale durante desarrollo)
2- Usa 'type annotations' para analizar mi código
3- De nuevo,sólo está activo durante desarrollo(esta sintaxis extra nunca llegará al navegador)
4- El compilado realmente no agrega ningun beneficio(a diferencia de Java u otros lenguajes compilados)

Hay webs como https://www.typescriptlang.org/play/ donde ver a qué Javascript me va a compilar el Typescript.Lo mejor es pensar en TS como un amigo

				VIDEO 569 ENVIRONMENT SETUP

Puedo instalar typescript de forma global(ts-node es una herramienta cli para terminal que combina los comandos ts y node)
NOTA: el compilador(tsc) viene  en el modulo typescript
>npm i -g typescript ts-node

* Puedo comprobar la instalación viendo la versión:
>tsc --help
>npm -g ls 
>ts-node --version
NOTA:fijate que puedo instalar VSCode al path desde settings y tipeando 'install path'.Ya lo hace él.Se recomienda instalar Prettier.
También es buena idea ir a Preferences y activar Format On Save.

						VIDEO 570 FIRST APP

Recuerda que el principal objetivo es que TS me ayude a ver los errores ANTES de ejecutar la aplicación en vez de después.

Para compilar un archivo en TS hay que usar tsc fileName.Esto creará su réplica en un .js:
>tsc index.ts <- generará el .js.

Ahora ya podría ejecutar el .js con node:
>node index.js

Claro que tener que hacer esto todo el rato es una mala idea.Para juntar las funcionalidades de compilar con tsc y ejecutar con node está el módulo ts-node(el cual instalamos anteriormente).
Lógicamente recibe el archivo TYPESCRIPT:
>ts-node index.ts
En un sólo paso puedo compilar el ts y ejecutar el js.

					CATCHING ERRORS WIHT TS

Podriamos tratar de imprimir proiedades que no existen:

 console.log(`
   The Todo with ID: ${ID} 
   Has a title of: ${title}
   Is it finished? ${finished}
   `)

   The Todo with ID: undefined 
   Has a title of: undefined
   Is it finished? undefined

Esto sucede al trabajar con Javascript.Pero TS me va a ayudar con estos errores,para que no los tenga.
Sabiendo que realmente las propiedades son completed(y no finished),id(en minúsculas) y title(también en minúsculas) debería tipar la respuesta

interface Todo {
   id: number;
   title: string;
   completed: boolean;
}

axios.get<Todo>(url).then(response => {
   const todo = response.data;
   const ID = todo.id;
   const title = todo.title;
   const finished = todo.completed;

NOTA: las interfaces en TS se usan para definir la estructura de un objeto.Asi pues,habrá un objeto por ahí en mi app de tipo Todo con las props id,title y completed.

Fijate que podia haber casteado la response.data como un Todo(pues es una instancia):

axios.get(url).then(response => {
   const todo = response.data as Todo;

Quizás tipar la respuesta sería mejor opción en este caso,pero debo memorizar que puedo inferir cualquier propiedad con un tipado casteandola(instance as interfaceName).Interesante.
Ya puedo ejecutar el archivo y no debería ver los undefined anteriores.
Fijate que estoy cogiendo el error antes de la ejecución y no después.Esto es una clara muestra de que he cogido y evitado un error antes de la ejecución(y es el mero propósito de la razón de ser de TS).

Bien,y que sucederá si sacamos todo esto a una función y le paso los argumentos en cualquier orden?:

   logTodo(ID,finished,title);
})

const logTodo = (id,title,completed) => {
   console.log(`
   The Todo with ID: ${id} 
   Has a title of: ${title}
   Is it finished? ${completed}
   `)
}
Esto actualmente ya da un error.De todas formas,de nuevo comprobamos que no vemos el error hasta que ejecutamos el programa.Es aqui donde entran las 'type annotations'.En cuanto ponga un tipo a los argumentos ya no podré pasar un orden cualquiera:

   logTodo(ID,finished,title);
})

const logTodo = (id:number,title:string,finished:boolean)
Esto me dará un error ya antes de ejecutar el script,pues no puedo pasar un boleano cuando espera un string.

				VIDEO 575 OVERVIEW OF THE COURSE

El objetivo de este minicurso es entender la sintax+features y despues centrarnos en la implementación(design patterns) mediante aplicaciones didacticas(última sección 7).Asi que primero habrá conceptos teóricos.
El orden de la teoria será:

1- Understanding basic types
2- Function typing + annotations
3- Type definition files
4- Arrays in TS
5- Modules systems
6- Classes + Refresher on OOP
7- Projects( design patterns)

						VIDEO 576 TYPES 

En TS casi cualquier cosa que pueda tener un valor tiene un tipo.Una función tendrá su tipo,un array también,un objeto,una clase,...
IMPORTANTE: tipar una variable,objeto,array,.. no se hace sin ningun motivo.Si el lenguaje sabe de que tipo es cierto valor,sabrá que métodos puedo usar,qué propiedades,etc...Dar un tipado es muy importante.
Ejemplo: si red es un string el lenguaje sabré que puedo usar charAt,concat(),includes,endsWith,startsWith,indexOf,,localeCompare,match(),... y muchos métodos más prebuilt por el lenguaje solo por decir que la variable es de tipo string.
Como atajo a decir que la variable puede usar todos esos métodos lo que se hace es darle un simple y único nombre,en este caso 'string'.
Puedo ver un tipo como una etiqueta para identificar a qué métodos y propiedades tengo acceso

					VIDEO 577 MORE ON TYPES

En TS está el tipo Number,que en otros lenguajes suele subdividirse en varios,en este caso engloba cualquier tipo de numero.
En TS también está el tipo Date,por ejemplo.Veamos todos ellos:

Primitive: number,boolean,void,undefined,string,symbol,null
Object Types: function,array,class,object

Los types de TS se dividen en estas dos categorías,básicamente.
El tipado tiene dos grandes propósitos:
1- Ayudar a TS a que identifique los errore y me ayude
2- Ayudar a otros desarrolladores a que entiendan el código

Cada valor que declare en Typescript debe tener un tipo.

				VIDEO 579 FEATURE ONE - TYPING

Se debe tipar todo.Ejemplo:
const today = new Date(); <- TS me sugeriŕá métodos para una Date
Es por esto que se debe tipar todo.

		VIDEO 580 FEATURE TWO TYPE ANNOTATIONS + TYPE INFERENCE

Una type annotation es una pequeña pieza de código para decirle a TS de que tipo es una variable(:type)

Type inference: TS va a intentar averigüar por él mismo de qué tipo es una variable

Si bien parecen lo mismo en la primera soy yo el que le dice a TS el tipo,en la segunda lo averigüa TS por sí sólo.

// la sintaxis para una type annotation es :type
let apples: number = 5; //:number es la type annotation
// en cuanto anote a apples como number ya no podré pasarle como valor nada más que un number

let speed:string = "fast"; //:string es la type annotation
//de nuevo no podré reasignarla más que a otro string

let hasName: boolean = true; //:boolean es la type annotation

let nothingMuch: null = null; //:null es la type annotation
//este es el primer type annotation que coincide con su valor

let nothing:undefined = null; //:undefined es la type annotation
//este es el segundo type annotation que coincide con su valor

let now: Date = new Date(); //:Date es la type annotation

				VIDEO 581 OBJECT LITERAL ANNOTATIONS

Realmente ya śe todo esto,excepto el último(fijate que lo usé en event:{prop:type;prop:type}

/* Built in objects */
let now: Date = new Date(); //:Date es la type annotation
let colors: string[] = ["red", "green", "blue"]; 
let myNumbers: number[] = [1, 2, 3]; 
let truths:boolean[] = [true, false, true]; 

// Classes(siempre Capitalizadas)
class Car {}
let car: Car = new Car();
// Object literal
let point:{x:number; y:number} = { x: 10, y: 20 };
No confundir el type(que usa punto y coma) en la declaración con la inicialización del object(asignación de valores).

Las mismas reglas se aplican para estos tipos.NO podré asignar un valor que no coincida con estas type annotations de la izquierda:

let point:{x:number;y:number} <- point va a ser un object que tenga las props x e y,y me dará error si no las tiene,y serán number ambas.

				VIDEO 583 FUNCTION TYPE ANNOTATIONS

La type annotation para una función es un tanto compleja:
/* Function fijate en :(args) => return*/
const logNumber: (i:number) => void = (i: number) => {
   console.log(i);
   };
Fijate que lo que está a la izquierda del '=' siempre es el type annotation,da igual que sea una funcion,una clase,un object,...Lo de la izquierda es el tipo.

					VIDEO 584 TYPE INFERENCE

Si voy al archivo y borro todas las type annotations veré que no tengo error:
const apple=5; <- veré que es de tipo number.
const texto='hola'; <- veré que es de tipo string

NOTA: esto es el sistema de inferencia de tipos de TS.Pero,¿cuando puedo dejar a TS que infiera el tipo sin riesgo alguno?
Si hago la declaración e inicialización(asignación de valor/es) en la misma linea TS va a saber inferir el tipo correctamente(con lo que acabo de escribir medio file gratis -_-, mira que es prehistoric este TS).

NOTA: si TS no es capaz de inferirle el tipo porque separo la declaración e inicialización o es un tipo que no sabe inferir(como Color[]) siempre le va a poner de tipo 'any'.
Bien,entonces,¿si TS es capaz de inferir correctamente los types,cuando debo ser yo el que lo haga?Esto es una gran pregunta y hay una respuesta para ella:
1- cuando separe declaración e inicialización debo usar las types annotations yo o TS no sabrá qué es.
2- Cuando quiera usar un type que no puede ser inferido
3- Cuando una función devuelva 'any' y yo quiera ser más especifico.
Estos son los tres escenarios en los que tengo que tipar yo.El resto lo puede hacer TS.

					VIDEO 585 THE ANY TYPE

El tipo 'any' básicamente significa que Typescript no tiene ni idea que tipo de valor está siendo retornado(o asignado),asi que puede ser cualquiera.
La funcion JSON.parse() devuelve any,ya que puedo estar parseando cualquier cosa.Fijate que esto es el punto 3 que acabamos de comentar

IMPORTANTE: any es otro tipo más.Si algo es de tipo any TS no va a tener ni idea de que funciones,propiedades puede usar(adiós a los beneficios de un lenguaje tipado).HAY QUE EVITAR EL USO DE ANY A TODA COSTA.
La verdadera finalidad de tipar es encontrar errores antes de ejecutar el script,si usamos any TS no va a poder ayudar.

				VIDEO 586 FIXING THE ANY TYPE

En el ejemplo que teniamos,dado que JSON.parse devuelve any,aunque estemos en la misma linea tendré que ayudar a TS:

/* WHEN TO USE ANNOTATIONS BY ME */
// 1) Function that returns the 'any' type
const json = '{"x": 10, "y": 20}';
const coordinates:{ x:number; y:number } = JSON.parse(json);
console.log(coordinates); // {x: 10, y: 20}

				VIDEO 587 DELAYED INITIALIZATION

Siempre que use la inicialización en otra linea TS me va a tipar con 'any'.(fijate que veré tres puntitos sobre el warning).Este es un caso tonto pero muy explicito de que tengo que tipar foundWord con foundWord:boolean.

// 2) When we declare a variable on one line and initialize it later
let words = ["red", "green", "blue"];//aqui si infiere
let foundWord; //<- aqui no infiere

for (let i = 0; i < words.length; i++) {
    if (words[i] === "green") {
       foundWord = true; //es aqui donde la inicio
    }
}
La solución es darle el tipo en la declaración:
let foundWord:boolean;
* Fijate que asi se quita el warning y como TS me avisa.

				VIDEO 588 WHEN INFERENCE DOESN'T WORK

Puede haber casos en los que la inferencia no funcione bien:
let numbers = [-10, -1, 12];
let numberAboveZero = false;

for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
       numberAboveZero = numbers[i];
    }
}  
En este caso dará error al asignarle numbers[i] dado que TS infirió que es de tipo boolean.Para arreglar esto tendré que usar:
let numberAboveZero:number | boolean = false;

Puede haber situaciones en los que una variable necesite usar más de un tipo por cuestiones de lógica de negocio(aunque se recomienda evitar este tipo de escenarios)

			VIDEO 589 MORE ON ANNOTATIONS AROUND FUNCTIONS

Ya hemos terminado de ver como trabaja la inferencia con variables.Es hora de ver lo mismo para funciones.
Fijate que la anotación que hemos visto en realidad es para la variable,no para la función:
 const logNumber: (i:number) => void = (i:number) => {console.log(i)};<- esta anotación es para tipar la variable logNumber,no para la función(la función está despues del '=').

IMPORTANTE: en una función TS puede usar la inferencia de tipos para adivinar el valor de retorno de esa función.Como programadores nosotros tenemos que tipar los argumentos de la función y podemos tipar el retorno.
En la funciones el type inference sólo funciona para el retorno,TS nunca va a tratar de adivinar el tipado de los argumentos.Veamos todo esto en un ejemplo:

const add = (a,b) => {} <- TS nunca va a adivinar el tipo de 'a' y 'b'!

* Asi pues tengo que tipar los argumentos
const add = (a:number, b:number):number => {
    return a + b;
}
* Fijate que he tipado el valor de retorno también.

				VIDEO 590 INFERENCE AROUND FUNCIONS

En el momento en que yo como programador especifico un valor de retorno para una función TS va a analizar el cuerpo de esa función para ver si cumple.

Si quisiera retornar otro tipo de valor como un string TS dará un error:

const add = (a:number, b:number):number => {
    return "fsdffdff";
}

En cuanto a la inferencia de tipos en las funciones es muy importante entender que TS nunca va a mirar por si la lógica está bien,simplemente verá qué es lo que devuelve el body de la función y lo pondrá como tipo.
Esto es un error,ya que puedo haberme confundido en la lógica.Ejemplo:

const substract = (a:number, b:number) => {
  a - b;
} 
En este caso simplemente veré que es de tipo ():void pero yo no quería eso,se me olvidó el return.Lógicamente quiero que devuelva un Number.

Es por esto QUE NO USARÉ LA INFERENCIA DE TIPOS EN FUNCIONES PARA EL VALOR DE RETORNO,porque TS no comprueba la lógica del cuerpo de la función.

					VIDEO 591 MORE ON TYPES AROUND FUNCIONS

En cuanto a funciones normales o anónimas la sintaxis es prácticamente idéntica:
/* Cuando sea una función normal la sintaxis es igual */
function divide(a:number, b:number):number {
  return a / b;
}
/* Lo mismo para funciones anónimas */
const multiply = function(a:number, b:number):number {
  return a * b;
}

					VIDEO 592 TYPES VOID AND NEVER

También hay una type annotation para especificar que una función no tiene ningun valor de retorno,no retorna un valor:

const logger = (message:string):void => {
  console.log(message);
}

IMPORTANTE: una función que retorna void también puede retornar null o undefined!
const logger = (message:string) => {
  console.log(message);
  return null; <- o también return undefined;
}

Hay otro tipo también para especificar que nunca vamos a llegar al final de la función(a su return)por ejemplo porque tiramos un Error antes:
const throwError = (message:string): never => {
  throw new Error(message);

Técnicamente lanzar un Error es como no lanzar nada y además al lanzarlo nunca se va a llegar al return de esa función.Este es un ejemplo muy raro que apenas se usa.
Sólo debo usar este tipo cuando realmente sea lo que quiero hacer(normalmente los errores se usan dentro de otras funciones que retornan lo que necesiten):

const checkSomething = (something:string):string => {
  if(!something){ throw new Error('bla bla bla') };
  return something

Fijate que esto es tremendamente común

				VIDEO 593 DESTRUCTURING WITH ANNOTATIONS

Imagina que tengo un object literal con propiedades que son una función,algo muy común

const todaysWeather = { 
  date: new Date(),
  weather: 'sunny'
}

Ahora podría tener algo como esto:
const logWeather = (forecast:{ date:Date,weather:string }):void => {
  console.log(forecast.date);
  console.log(forecast.weather);
}
logWeather(todaysWeather);

Pero que pasa si quisiera usar destructuring?Realmente sólo tengo que cambiar forecast(el objeto) por la desestructuración

const logWeather2015 = ({date,weather}:{date:Date,weather:string}) => { } 

Bien fácil

NOTA: The semi-colon is used when we're annotating an object literal, not function parameters.
EDIT: Actually now it's not clear to me, because lecture 602. Long Type Annotations, he reverts back to using semi-colons when annotating the function parameters. From what I can see, semi-colon is the preferred style (and I think was the only way for a while) but now you can use either semi-colon or comma.
Parece que para usar una type annotation en un object literal hay que usar semicolon,pero no si está como argumento de una función,que permite tanto semicolon como comma.

					VIDEO ANNOTATIONS AROUND OBJECTS

Ya hemos visto type annotations con variables y funciones.Sólo nos quedan los objects:
/* Teniendo un object literal como este */
const profile = {
  name: 'John',
  age: 30,
  coords: {
    lat: 0,
    lng: 15
  },
  setAge(age:number):void{
    this.age = age;
  }
}
* Imagina que quiero desestructurar y tipar la edad.No voy a usar { age }:number aunque sepa que es un number porque realmente es de tipo profile.age,no number */

Lo que se hace es decir de que tipo de prop es y despues el tipo de esa prop
const { age }:{age:number} = profile;

Fijate que esto viola la regla anterior de :number,pero porque es la desestructuración de un object .Imagina que quisiera sacar el name también:

const { age, name }:number = profile;<- está claro que name no es de tipo number,asi que es const {age}:{age:number}=objectLiteral 

Esta sería la forma de sacar dos o más  propiedades,por cada una que saco la saco con su correspondiente par de  propName+:+propType
const { name,age:edad }:{name:string,age:number} = profile;

const { coords:{ lat, lng } }: {coords:{ lat:number;lng:number}} = profile;

Como puedo ver es bastante sencillo,sólo hay que trabajar más con ello.Además siempre tendré este tutorial para volver aqui si es necesario.

				VIDEO 595 ARRAYS IN TYPESCRIPT

Cuando use arrays en TS básicamente tendré toda la funcionalidad de los arrays de JS(map,reduce,filter,find,some,foreach,for of) pero la única diferencia estará en sus elementos.
Dentro del array debe haber una consistencia en sus tipos.Sólo podré usar Strings,o Numbers,ya que estoy en un lenguaje tipado.Veamos algun ejemplo:

// de nuevo TS puede inferir si la declaración e inicialización van juntas
const carMakers = ['ford', 'toyota', 'chevy']; <- no hace falta :string[]

// Sin embargo no lo puede hacer con un arreglo vacio(lo pone a any[]:
const anyTyped = [] <- aqui si que debo ponerle el tipo yo

// también lo va a inferir en arrays multidimensionales si lo inicio
const carsByMake = [
  ['f150'],
  ['corolla'],
  ['camaro']
];

// y de nuevo la única vez que tendría que tiparlo yo será cuando se inicie vacío
const carsByMakeEmpty:string[][] = [];

					VIDEO 596 WHY TYPED ARRAYS

1º: TS puede hacer la inferencia no sólo cuando le inicie el arreglo,sino cuando extraiga un elemento de un arreglo tipado ya sabrá de que tipo es:
* TS sabrá que car es un string pues lo he sacado de un arreglo de strings
const car = carMakers[0];

2º: TS puede impedirme que añada valores incompatibles al arreglo si lo tipo.
//* Preventing incompatible values
carMakers.push(100); <- no podré añadir un number a un string[]

3º: obtendré ayuda con las funciones para arreglos map,forEach,reduce...
// We get help with arrays functions
carMakers.map( (car) => car.toUpperCase()); <- TS sabe que car es un string asi que me sugerirá métodos para strings

4º: Flexibilidad: aún con todo esto puedo usar varios tipos en un arreglo.Imagina que necesito un arreglo de fechas que puedan ser Dates o strings válidos:

* Fijate que de nuevo lo va a inferir si lo inicio aunque sea un array de tipado flexible(string | Date)[]
const importantDates: = [new Date(), '2030-10-10'];

NOTA: Para tipar un arreglo flexible se ponen los tipos entre parentesis y se separan con un pipe (Number | Date)[] <- fijate que podrián ser mas de dos,simplemente se concatenarían.
Esto va a ser útil para gestionar nulls o undefineds.

NOTA:recuerda que hay que evitar el any[] lo máximo posible.

IMPORTANTE:¿Cuando debo usar arrays?Siempre que necesite representar una coleccion de registros/elementos con cualquier orden arbitrario.Esto puede parecer muy básico,pero en TS hay otra estructura muy similar llamada tupla,la cual tiene pequeñas diferencias.

					VIDEO 599 TUPLES IN TYPESCRIPT

Una tupla es una estructura parecida a un array donde cada elemento representa alguna propiedad de un registro/elemento,y en un determinado orden.

Ésta es la gran diferencia,mientras que un array guarda una colección de registros(en un orden arbitrario) una tupla guardará una colección de propiedades(en un oden determinado) que describen UN ÚNICO REGISTRO
Además,debido a su naturaleza,dentro de una tupla mezclaré muchos tipos de valores.Veamos un ejemplo rápido:


/* Imagina que quiero representar una coleccion de este objeto */
const drink = {
    color: 'brown',
    carbonated: true,
    sugar: 40
};


// si creara un arreglo de (string | number | boolean)[] realmente no sabría en que orden va cada uno de ellos
const pepsi:(string | number | boolean)[] = ['brown',true,40];
pepsi[0] = 'brown';
pepsi[1] = true;

// pero puedo usar un tipo [string,boolean,number] para que sea una tupla en vez de un arreglo,con lo que el orden debe ser exactamente el mismo que yo defina
const pepsiTuple:[string,boolean,number] = ['brown',true,40];

// ya no podré cambiar el orden
// pepsiTuple[0] = false;
// ni tampoco añadir más elementos
// pepsiTuple[3] = 'brown';

// normalmente se usa un type alias en vez de usar [string,boolean,number]
type Drink = [string,boolean,number];
// con un type alias puedo crear un nuevo tipo para usar donde quiera
const pepsiTuple2:Drink = ['brown',true,40];
// sin embargo parece que usar el type alias ahora no muestra los errores
pepsiTuple2.push(50);

				VIDEO 601 WHY TUPLES AND WHEN TO USE?

//realmente las tuplas no son útiles,¿que son estos dos numbers?
const carSpecs:[number,number] = [400,3354];

// es mucho mejor ser especificos y usar un object literal:
const carStats = {
    horsepower:400,
    weight:3354
} 
Si bien la documentación hace hincapié en que existen y se usen no parecen muy útiles y no se usan mucho(mejor un object literal).

						VIDEO 602 INTERFACES

Entender las interfaces + clases me va a permitir diseñar excelentes aplicacionesen TS.Tengo que entender como usarlas conjuntamente y por separado.

NOTA: las interfaces se usan para crear un nuevo tipo(a new type) describiendo los nombres de las propiedades y los tipos de las mismas para una instancia de este nuevo tipo(pues parece una clase,asinto)
IMPORTANTE: cuando creo una interfaz estoy creando un nuevo tipo usable por toda mi aplicación,igual que un string o un number,solo que es un custom type.

				VIDEO 603 LONG TYPE ANNOTATIONS

Imaginando que tengo un objeto que representa un coche viejo:

const oldCivic = {
    name: 'civic',
    year: 2000,
    broken: true
};

const printVehicle = (vehicle: {name:string;year:number;broken: boolean}):void => {
  console.log(`Name: ${vehicle.name}`);
  console.log(`Year: ${vehicle.year}`);
  console.log(`Broken: ${vehicle.broken}`);
}

printVehicle(oldCivic); 
Pueod observar que la type annotation queda excesivamente larga,además que si añadiera otra propiedad a ese objeto quedaría obsoleta(0 reusabilidad)

				VIDEO 604 FIXING ANNOTATIONS WITH INTERFACES

Para no tener que usar types annotations tan largas y poco reusables se usan interfaces.Recuerda que van capitalizadas:

interface Vehicle {
    name: string;
    year: number;
    broken: boolean;
}

const printVehicle2 = (vehicle: Vehicle):void => {
  console.log(`Name: ${vehicle.name}`);
  console.log(`Year: ${vehicle.year}`);
  console.log(`Broken: ${vehicle.broken}`);
}

Incluso voy a poder declarar propiedades como opcionales.Fijate que se usan masivamente para tipar los object literals de JS.

				VIDEO 605 SYNTAX AROUND INTERFACES

/* En cuanto a la sintaxis admite todo(Date,functions,Promises) */
interface VehicleTwo {
  name: string;
  year:Date;
  broken: boolean;
  //sintaxis:function():returnType
  summary():string;
}

const newCivic = {
    name: 'civic',
    year: new Date(),
    broken: true,
    summary():string{
        return `Name of the car: ${this.name}`;
    }
}

const printNewVehicle = (vehicle: VehicleTwo):void => {
  console.log(`Name: ${vehicle.name}`);
  console.log(`Year: ${vehicle.year}`);
  console.log(`Broken: ${vehicle.broken}`);
  console.log(`Summary: ${vehicle.summary()}`);
} 
NOTA: recalcar que admite tipos más complejos como Date y funciones.

					VIDEO 606 FUNCTIONS IN INTERFACES

¿Que pasa si sólo quisiera tener la función summary que hace un reporte?Sería más apropiado usar esta interfaz:

interface Reportable {
    summary():string;
}

¿Y si tuviera este otro objeto literal?
const drinkTwo = {
    color: 'brown',
    carbonated: true,
    sugar: 40,
    summary():string{
        return `My drink has ${this.sugar} grams of sugar`;
    }
}

IMPORTANTE: es aqui donde viene toda la razón de ser de las interfaces en TS(recuerda que son clases).Fijate que ambos objetos car y drink tienen la funcion summary().
Es aqui donde esta interfaz Reportable se comporta como una clase abstracta,cada objeto que sea de ese tipo desarrollará la funcion summary de la forma que desee(métodos abstractos).

NOTA:es por todo esto que los objetos deben estar tipados con una interfaz.Esa interfaz definirá las reglas a cumplir

					VIDEO 609 CLASSES 

Una clase es un 'plano' para poder crear un objeto con algunos campos y métodos que representarán algo del mundo real.
El nombre de una clase siempre va Capitalizado:

class Vehicle { 

  drive():void {
    console.log("chugga chugga");)   
  }
}


const vehicle = new Vehicle();
vehicle.drive();
Para instanciar un objeto se usa la keyword 'new'.

				VIDEO 610 BASIC INHERITANCE

EN TS hay herencia de clases,se usa la keyword 'extends'.Recuerda que también hay herencia de interfaces.Fijate que en el ejemplo siguiente hay sobreescritura(override de métodos) como en cualquier lenguaje POO.

class Vehicle { 
  drive():void {
    console.log("chugga chugga")   
  }
  honk():void {
    console.log("beep")
  }
}


const vehicle = new Vehicle();
vehicle.drive();
vehicle.honk();

class Car extends Vehicle {
  drive():void {
    console.log("vroom")
  }
}
const car = new Car();
car.drive();

				VIDEO 611 CLASS METHOD MODIFIERS

Los modificadores son palabras reservadas que puedo usar en un método para modificar su nivel de acceso:

public: visible por todos(modificador por defecto)
private: sólo visible dentro de la misma clase que lo define.Puede ser útil para que lo usen otros métodos con mismo o diferente nivel de acceso dentro de esa clase,en su lógica.
protected: visible dentro de la misma clase o de cualquier otra que herede de la primera.

Recuerda que el modificador por defecto es public.
NOTA:la razón de marcar métodos como privados suele ser restringir el acceso a métodos que puedan manipular severamente una clase o un resultado.
Como resultado de este método tan peligroso se le etiqueta como privado para el resto de developers.

					VIDEO 612 FIELDS AND CONSTRUCTORS

IMPORTANTE:en TS si una clase hereda de otra también hereda su constructor.Un constructor es un método que se invoca automáticamente al crear una instancia de una clase.Sirve para inicializar propiedades:

class Vehicle {
  color: string;
  constructor(color: string) {
    this.color = color;
  } 

  public drive(): void {
    console.log("chugga chugga")
  }
  public honk(): void {
    console.log("beep")
  }
}
const vehicle = new Vehicle('orange');
	
NOTA: hay un shortcut para no tener que crear la propiedad e inmediatamente despues pasarla por argumento.Simplemente hay que pasar el argumento con un modificador de acceso de tipo public:

class Vehicle {
  constructos( public color:string) <- esto crea una propiedad color:string(con acceso public)
NOTA:de igual manera se puede catalogar una propiedad como private y sólo será accesable en esa clase.

				VIDEO 613 FIELDS ALONG WITH INHERITANCE

TS automáticamente llama al constructor de la clase Base si una clase hija no define uno.Es por esto que vemos el error en new Car() ya que no he definido un constructor para Car y esta llamando al de Vehicle y espera un color

IMPORTANTE: en cuanto defina un constructor en la clase hija tendré que hacer una llamada al del padre,pasandole cuantos argumentos fuera necesario:

class Car extends Vehicle {

  constructor(public wheels:number,color:string){
    super(color); <- debo llamar al constructor padre y pasarle el color
  }
Fijate que public wheels es el shortcut y va a crear una propiedad wheels en esta clase pero color:string no va a crear una propiedad en esta clase.

const car = new Car(4,'blue');

Por último,usar y dominar la POO es básico,creando código reusable y desacoplado.

					VIDEO 615 FIRST WEB APP

Vamos a crear una pequeña app web de Users y Companies.MOstraremos su ubicación en un GoogleMaps con un marcador(para el User y su Company).El objetivo es entender como funcionan las clases + interfaces en una aplicación real.

NOTA: para poder correr TS en el browser voy a necesitar una libreria CLi llamada parcel-bundler.Se instala en global:
>npm i -g parcel-bundler
NOTA: instalar la version 1.12.3
'npm i -g parcel-bundler@1.12.3'
O usar 'parcel' pues cambió de nombre el módulo.

				VIDEO 616 BUNDLING WITH PARCEL

Parcel trabaja de esta forma: puedo crear un index.html con un <script> que use un .ts .Parcel compilará ese ts a js para el browser.
Parcel es una herramienta fantástica para configurar rápidamente un pequeño proyecto que use Typescript.

Por ejemplo,nosotros usaremos:
 <script src="./src/index.ts"></script> 

PAra ejecutar parcel simplemente apuntar al .html.Parcel trae un servidor web embebido
npx parcel src/index.html <- en mi caso no está dentro del src(y no necesito a npx)
Hay varias formas de configurar y ejecutar parcel.Parcel ejecutará el servidor embebido en el puerto 1234
NOTA: Parcel lo que hace es compilar a js e inyectar ese archivo:
<script src="/index.270367c6.js"></script> <- le pondrá cualquier hash random

					VIDEO 617 PROJECT STRUCTURE

En total se nos presentan 3 clases: Map.ts User.ts y Company.ts.
Recuerda que la convención dicta que si un archivo sirve para crear una clase y exportarla su nombre debe ir capitalizado.

NOTA:una vez que declare una propiedad puedo asignarla un valor en la misma linea on el el constructor:

export class User {
  name: string;
  location:{
    lat: number,
    lng: number
  };
  constructor(){}
}

				VIDEO 619 GENERATING RANDOM DATA

Vamos a generar fake data con el módulo faker de npm.Este paquete otorga la habilidad de generar random data de diferentes tipos,lo cual es genial.Es un paquete muy ligero.
Doc: https://www.npmjs.com/package/faker

La doc no es muy clara,pero puedo usar diferentes módulos(name,phone,random) y despues un método sobre ellos:

const randomName = faker.name.firstName()
const phone = faker.phone.phoneNumber()
Puedo ver que en el módulo address tengo a latitude y longitude.
Para importarlo puedo usar import,sin embargo me dará el siguiente error:
Could not find a declaration file for module 'faker'

					VIDEO 620 TYPE DEFINITION FILES

Cuando trabaje en TS voy a ver muchas veces este error.Realmente al trabajar en TS yo puedo usar cualquier libreria JS(como faker) pero TS no sabŕa los tipos de esta libreria.
Dado que la libreria está en JS,TS me da este error.La solución son los 'type definition files'.
Puedo ver estos type definition files como adaptadores entre JS y TS.Este file o adaptador tiene el tipado de toda la libreria.
Algunas librerias como axios ya incluyen los archivos con los types para TS,es por esto que no tuve que hacer nada en los dos proyectos.

NOTA: dado que es imposible saber cuando una libreria incluye sus tipos o no,simplemente puedo mirar por este error.Si un módulo me dice que no puede encontrar su declaration file es que tengo que instalarlo manualmente.

Para instalarlo ni siquiera tengo que saber el nombre de estos file.Siempre va a ser @types/{library name}. asi pues instalo los archivos de declaración de tipos para faker:
>npm i @types/faker -D

recuerda que el tipado puede ir en modo dev.

				VIDEO 621 USING TYPE DEFINITION FILES

Uno de los beneficios que tendré al usar los types es que puedo usar CTRL+click en variables,métodos o instancias como 'faker' y ver toda su descripción.
Seguramente iré a un archivo tipo index.d.ts(la d es de definition)
Cualquier archivo con extensión .d.ts suele ser un type definition file:


declare const fakerStatic: Faker.FakerStatic;

declare namespace Faker {
    interface FakerStatic {
        locale: string;
        setLocale(locale: string): void;

        address: {
            zipCodeByState(state: string): string;
            zipCode(format?: string): string;
            city(format?: string): string;
            cityName(): string;

Alli podré ver que por ejemplo cityName es una función que devuelve un string(esto es importante ya que latitude():string y longitude:():string también lo hacen y uo quiero Numbers).Esto no lo hubiera podido ver tan fácil sin los @types.

No sólo esto,sino que si analizo la propiedad name veré la función firstName que puede recibir un argumento gender opcional de tipo number.Esto ni siquiera aparece en su documentación de npm.Los types tienen la mejor documentación,la más actual :
name: {
  firstName(gender?:number):string;

NOTA: cuando tengo una propiedad que es un objeto al crear una instancia esta propiedad no crea ese sub-objeto directamente:

export class User {
  name: string;
  location:{  <- propiedad location de tipo object
    lat: number,
    lng: number
  };
  constructor(){
    this.name = faker.name.firstName();
    this.location.lat <- dará error cannot access property 'lat' of undefined
    };
  }

SOMOS NOSOTROS LOS RESPONSABLES DE INICIALIZAR la propiedad de tipo Object  
  this.location = {
      lat: Number(faker.address.latitude()),
      lng: Number(faker.address.longitude())
      }
    };
NOTA:Number y el unary operator '+' hacen lo mismo:
Number('45.45') <- 45.45 as number
+'45.45' <- 45.45 lo mismo

					VIDEO 622 EXPORT STATEMENT IN TYPESCRIPT

NOrmalmente en el archivo donde declare una clase no tendré más código adicional,asi que hay que exportar esa clase para usarla en otro archivo.

export class User {
  name: string;

Despues hay que importarla en cualquier file:

import { User } from "./User"; <- fijate que no es una export default
EN TS normalmente no se usan las export default,aunque si existen:

export default 'red'; <- puedo exportar un valor por defecto.
Sin embargo la convención es no usar nunca export default.Asi siempre que importe algo tendré que usar {  } siempre,siendo más lógico y claro.
Esta regla no se usa para imports de módulos npm,ya que no depende de mi.

Con esto en mente exporto la clase y la importo en el index.ts:

export class User

import { User } from './User';
const user = new User(); 
console.log(user) <- recuerda que llamo a faker en el constructor

NOTA:hubo que usar type="module" e importar faker/locale/en_US

				VIDEO 623 DEFINING A COMPANY

De nuevo ojo con los bugs de esta libreria.Fijate que también de nuevo tengo que iniciar el objeto en el constructor y parsear el string.

import faker from 'faker/locale/en_US';

export class Company {
  companyName: string;
  catchPhrase: string;
  location: {
    lat: number;
    lng: number;
  };
  
  constructor() {
    this.companyName = faker.company.companyName();
    this.catchPhrase = faker.company.catchPhrase();
    this.location = {
      lat: parseFloat(faker.address.latitude()),
      lng: parseFloat(faker.address.longitude())
    };
  }
}

					VIDEO 625 ADDING GOOGLE MAPS

Para usar GoogleMaps tengo que habilitar el billing en mi cuenta de Google Developer.Si no quiero hacer esto puedo usar esta pre-generated key:
AIzaSyBNLrJhOMz6idD05pzfn5lhA-TAw-mAZCU

Se pone en una etiqueta script:
<script src="https://maps.googleapis.com/maps/api/js?key=..."></script>

Si bien se pueden usar módulos npm usar esta forma es,de lejos,la forma más fácil

NOTA: lo que instalamos es la maps Javascript API de Google
Si he metido bien la key podré ver en 'network' un status de 200
Sin embargo,la prueba definitiva es tipear 'google' en la consola.Deberé ver el bojeto entero:

<google
>{maps: {…}}

			VIDEO 627 GOOGLE MAPS INTEGRATION WITH TYPESCRIPT

NOTA. la libreria para los types definition files que usa Stephen ha sido deprecada(era @types/googlemaps.En su lugar ahora lleva un punto:
>npm install @types/google.maps

Adicionalmente,veré este error:
Cannot find name 'google'.ts(2304)

Para corregir esto se usa una tripe slash directive en la primera linea del index.ts:
/// <reference types="@types/google.maps" />

IMPORTANTE: normalmente instalo módulos de npm.Pero esta vez he usado un script.Este script va a ser añadido en mi proyecto como una variable global.Es por esto que pude tipear en la consola de las DevTools 'google' y veia la info.
Sin embargo,si voy al IDE y tipeo 'google' no veré la ayuda.Necesito los type definition files.
NOTA:puedo usar los type definition files no sólo para módulos npm,sino para etiquetas script añadidas directamente en mi index.html(fijate que ajax,jquery,..muchos usan tags <script>)
Asi pues instalo el módulo:
>npm i @types/

NOTA:las tripe slash directives son comentarios mono-linea conteniendo una única XML tag.El contenido de esa tag se usa como una compiler directive.Es decir que su contenido se usa en la compilación
/// <reference types="@types/google.maps" />

Ahora debería poder tipear google y ver en el onHOver que me redirecciona a namespace google.Ya tengo el tipado.Lo siguiente va a ser mostrar el mapa.

			VIDEO 628 EXPLORING TYPE DEFINITION FILES

Ahora que TS entiende el tipado puedo analizar:
declare namespace google.maps {
  export class Map extends...
Esto significa que habrá una variable global google con una propiedad maps y dentro de ella ya está todo.
NOTA:para ver mejor un archivo tan grande puedo comprimir su interior.Para ello tipo fold level 2 en el IDE:
Alli podré ver por ejemplo la clase Marker,la cual usaremos.Puedo observar que saber leer un archivo de documentación es vital.

declare namespace google.maps {
  export class Map extends MVCObject {...}
  export interface Padding{...}
  export class Marker{...}

De aqui debería poder sacar como crear un Map o un Marker y si expando la clase entender que argumentos puedo usar.

Fijate además que el constructor de Map es:
  constructor(mapDiv:Element|null,opts?:MapOptions)
De aqui debo sacar que el segundo arg es opcional y el primero es un elemento HTML.Si voy a la interface MapOptions:
interface MapOptions {
    /**
     * Color used for the background of the Map div. This color will be visible
     * when tiles have not yet loaded as the user pans. This option can only be
     * set when the map is initialized.
     */
    backgroundColor?: string|null;
    /**
     * The initial Map center.
     */
    center?: google.maps.LatLng|null|google.maps.LatLngLiteral;
    /**
     * When <code>false</code>, map icons are not clickable. A map icon
     * represents a point of interest, also known as a POI. By default map icons
     * are clickable.
     */
Puedo observar como aqui si que me ayudará un montón este file.
NOTA:la key que proporcionan parece que va bien.

				VIDEO 629 HIDING FUNCTIONALITY

Hagamos un repaso de lo que puedo hacer en este index.ts ahora mismo:
1º: puedo crear una new Company
2º: puedo referenciar todas las propiedades de esa company(name,lat,long..)
3º: puedo crear un User
4º: puedo referenciar sus props(name,lat,long...)
5º: tengo acceso a métodos como setZoom,setCenter,puedo crear un Map,un Marker,llamar a setStreetView,panTo,getHeading.

Pero fijate que si llamo a ciertos métodos de la variable global google puedo romper la app.¿Como podria hacer que otros dev no pudieran llamar a ciertos métodos que rompan la app?
Nos gustaría limitar las acciones que un dev pueda usar en este file a : crear una Company,crear un User, crear un Map y Add a Marker.Es obvio que esto sería ideal,pero como limitamos esta librería?Por defecto viene abierta...
La solución será crear una CustomMap class que cree un map y tenga acceso a ese addMarker.
Fijate que es una idea genial,en vez de dejar la libreria abierta a todos.

					VIDEO 630 ¿WHY USE PRIVATE MODIFIERS?

Fijate en la gran mejora que es aislar la librería con esta simple clase:
export class CustomMap {
  // el tipo es la clase 
    private googleMap: google.maps.Map;

    constructor(divId: string) {
        this.googleMap = new google.maps.Map(document.getElementById(divId), {
            zoom: 2,
            center: {
                lat: 0,
                lng: 0
            }
        });
    }
Para llamarla simplemente la importo y la instancio:
new CustomMap('map');
Algo tan sencillo protege la libreria entera de malos usos

						VIDEO 631 ADDING MARKERS

Vamos a empezar primero escribiendo mal el código.Después usaremos interfaces y por ello un código más reusable.
NOTA: en TS las clases tienen un comportamiento dual.Puedo usar una clase para crear una instancia de un objeto,pero también puedo usar una clase(o una variable que se refiere a una clase) para referirme a ese tipo también:

import { User } from './User'; <- esto es una variable que se refiere a una clase,puedo crear una instancia o usarla para tipar.
Hay otras cosas en TS que tienen este comportamiento de poder usarsesimultáneamente como valor o para tipar.

addUserMarker(user:User):void {
  

addCompanyMarker(company:Company):void {

NOTA: debo acostumbrarme a leeer esos .d.ts.Podré ver cosas tan interesantes como:
 class Marker extends google.maps.MVCObject {
    constructor(opts?: google.maps.MarkerOptions|null);
    /**
De aqui puedo sacar que al crear un Marker puedo pasar un arg opcional de tipo MarkerOptions.De nuevo si voy a esa interfaz veré nicelly commented all properties of it.
Entre ellas veré esta:
 * Map on which to display Marker. The map is required to display the marker
     * and can be provided with {@link google.maps.Marker.setMap} if not
     * provided at marker construction.
     */
    map?: google.maps.Map|null|google.maps.StreetViewPanorama;
Aunque es opcional,es otra que en realidad no lo es,pues si creo un Marker tiene que saber en qué mapa debe nacer.
Y de nuevo veré que también necesita una position. 

Bien,volviendo al código que vamos a crear mal.Seguramente nuestra primera idea sería algo como esto:
   
 addUserMarker(user:User):void {
        new google.maps.Marker({
            map: this.googleMap,
            position: {
                lat: user.location.lat,
                lng: user.location.lng
            }
        })
    }


    addCompanyMarker(company:Company):void {
        new google.maps.Marker({
            map: this.googleMap,
            position: {
                lat: company.location.lat,
                lng: company.location.lng
            }
        })
    }

Bien,es obvio que los dos métodos son iguales! XD

				VIDEO 633 ONE POSSIBLE SOLUTION

En este video vamos a ver un approach que parece bueno pero tiene otra downside.Despues refactorizaremos a la solución correcta final.

SOLUCIÓN UNO:
    addMarker(mappable: User | Company ):void {
        new google.maps.Marker({
            map: this.googleMap,
            position: {
                lat: mappable.location.lat,
                lng: mappable.location.lng
            }
        })
    }   
Si bien pudiera parecer que es correcta no lo es.Typescript por detrás va a coger ambas clases y va a comparar propiedades.Va a rechazar las que sólo sean de una de las dos,limitandome el uso.Dado que User y Company tienen 'map' y 'position' está bien,pero no podré usar catchPhrase de una Company pues User no la tiene.Este es un downside.Sin embargo es aún mas grave la falta de reusabilidad y escalado,que pasa si quiero agregar una tercera clase que puede crear un Marker?

Tendría que volver al método y agregar otro |.Definitivamente no es un buen apprach.
NOTA: es un método con fuerte acoplamiento(tigh coopling)

			VIDEO 634 RESTRICTING ACCESS WITH INTERFACES

Realmente la mejor solución es usar una interface,con reglas de como debe lucir un addMarker Mappable.
Una interface es como un gatekeeper,un portero que restringe el acceso a un métdo cualquiera.La llamaremos Mappable por semántica.

Fijate en la inversión que ha habido: en vez de que el método tenga que satisfacer a la clase User,Company,Park,Car,... ahora cada clase tiene que satisfacer a la interfaz Mappable para poder trabajar con el método addMarker.El control pasó a la interfaz y se liberó el método.

* Instructions to every other class on how the can be an argument of AddMarker
interface Mappable {
  location: {
    lat: number;
    lng: number;
  }
};
ASi,si una clase quiere ser argumento de la función tendrá que satisfacer a la función(teniendo que tener como prop un objeto location:{lat:number;lng:number}.

    addMarker(mappable: Mappable): void {
        new google.maps.Marker({
            map: this.googleMap,
            position: {
                lat: mappable.location.lat,
                lng: mappable.location.lng
            }
        })
    }
LA reusabilidad y bajo acoplamiento salta a la vista.

				VIDEO 635 IMPLICIT TYPE CHECKS

 Realmente me podría llevar el código(el file) a otro proyecto.Es muy reusable.La clase está desacoplada totalmente.Puedo implementar este archivo(la clase) donde quiera y no dará problema.

Fijate que poner una interfaz en el medio ha sido una idea genial.REcuerda que las comparaciones que hace TS(¿cumple este arg que me dan con la interfaz Mappable?) ocurren behind the scenes y son automáticas.No hay que hacer nada más.
IMPORTANTE: A esto se le llama 'IMPLICIT CHECK' o chequeo implícito de tipos. 

				VIDEO 636 SHOWING POPUP WINDOWS

Puedo crear un PopUp Modal que muestre cierta info cuando se haga hover sobre un marker.Se usa la clase InfoWindow({content: contentString}).Aparte hay que crear un listener al marker con markerInstance.addListener('event',()=>{infoWindowInstance.open(map,marker).Sencillo.

addMarker(mappable:Mappable):void {
  const marker = new google.maps.Marker({
    map: this.googleMap,
    position: {
      lat: mappable.location.lat,
      lng: mappable.location.lng
   }
 })
  marker.addListener('event', () => {
    const inforWindow = new google.maps.InfoWindow({
      content: "Hi there!!"
    })
    infoWindow.open(this.googleMap,marker)
  })
}
Todo esto está muy bien,pero mostrar un simple 'Hi there' no le dirá al usuario si el marker es un User o una Company.Sería genial que cada tipo de Marker displays something different

        	VIDEO 637 USING INTERFACE DEFINITIONS

De entre varias cosas que podríamos hacer,hay una muy buena y es hacer responsable al argumento mappable(es decir,a la interfaz guardiana) de tener un método encargado de mostrar el content.
Fijate que tiene mucho sentido.Asi que la interfaz va a tener un nuevo requirement o regla en forma de method:

interface Mappable {
  location: {
    lat:number;
    lng:number;
  };
  markerContent():string;
}

Desde ahora,la interfaz tendrá un method markerContent que devuelve un String.In order to be able to be chosen as argument las clases deberán desarrollar este método.Amazing.

Cada clase lo puede desarrollar como quiera,lógicamente:
  markerContent(): string {
    return `
      <div>
        <h1>Company Name: ${this.companyName}</h1>
        <h3>Catchphrase: ${this.catchPhrase}</h3>
      </div>
    `;
  }

				VIDEO 638 OPTIONAL IMPLEMENTS CLAUSES

Fijate que acabamos de obligar a cada clase que quiera ser un argumento de cierta función a implementar otra cláusula.Hagamos lo mismo con una propiedad color,pues sería buena idea que cada marker pueda ser de un color diferente!

Si añado a la interfaz esta nueva regla,veré en la llamada al método que las clases dan error.Es posible que éste no sea el mejor sitio para mostrar el error,¿cierto?.Vamos a añadir código que mejore este feedback de errores.

Empezamos por exportar la interfaz:
export interface Mappable {
 ...
  }
La vamos a importar en cada clase.
import { Mappable } from './CustomMap';

export class User implements Mappable{

En cuanto la implemente veré que el error está en la clase y no en el método,lo cual es mucho mejor,más claro,conciso y lógico.Además que el error y donde corregirlo están juntos.Putos pros :(

NOTA: TS soporta múltiple herencia para interfaces,para clases se pueden usar mixins,pero directamente sólo puede heredar de otra clase(varias interfaces,una clase)

RESUMEN: hacer que una clase herede de una interfaz va a ayudar a TS a que identifique los errores,y va a obligar a la clase a cumplir con lo que dicte la interfaz o interfaces que herede,teniendo que implementar sus propiedades y métodos.
Puedo observar que una clase que implementa una interfaz va a ayudarme mucho como dev a saber que tengo que desarrollar en ella(y al resto de devs).

				VIDEO 639 APP WRAPUP - QUICKREVIEW

1- Fijate que siempre hemos tratado de limitar y separar lo que se puede hacer en cada archivo.Unos(los de las clases) sólo son para definir,otros como el index solo instancian clases.En cada file SOLO SE PUEDEN HACER LIMITADAS ACCIONES
Y como resultado de ésto,la clase CustomMap es incluso reutilizable fuera de este proyecto,está totalmente desacoplada.
Se intenta dejar cada file como una 'black box' donde sólo se pueda hacer lo justo desde cada file.

2- Invertimos el control en el método addMarker,ahora lo tiene el método,gracias a una interfaz, y las clases deben cumplir con ella.Al principio era al revés,el método debía cumplir con las clases,siendo muy mala idea(no escalabilidad,reusabilidad,legibilidad confusa,...).
Además con la interfaz es muy fácil añadir una nueva regla a cumplir para poder ser un argumento de ese método.

3- Mejoramos el display de los errores sacandolos del método haciendo que TA los muestre en la clase simplemente implementando la interfaz.Fue un paso sencillo pero muy ilustrativo.El que una clase implemente la interfaz hará que deba cumplir con el contrato de ésta directamente ya en la clase,centralizando los errores al mejor lugar donde pueden estar.
La herencia de interfaces es algo que debo dominar.Estas son los tres aspectos generales que hicieron mejorar el código.


