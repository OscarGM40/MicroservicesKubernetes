					BASICS OF TYPESCRIPT

						VIDEO 568 OVERVIEW

El mayor objetivo de Typescript es ver los errores en el editor,antes de que se compile el TS a JS..Simplemente intenta tipar el Javascript.

1- TS intenta cogerr los errores durante desarrollo(sólo vale durante desarrollo)
2- Usa 'type annotations' para analizar mi código
3- De nuevo,sólo está activo durante desarrollo(esta sintaxis extra nunca llegará al navegador)
4- El compilado realmente no agrega ningun beneficio(a diferencia de Java u otros lenguajes compilados)

Hay webs como https://www.typescriptlang.org/play/ donde ver a qué Javascript me va a compilar el Typescript.Lo mejor es pensar en TS como un amigo

				VIDEO 569 ENVIRONMENT SETUP

Puedo instalar typescript de forma global(ts-node es una herramienta cli para terminal que combina los comandos ts y node)
NOTA: el compilador(tsc) viene  en el modulo typescript
>npm i -g typescript ts-node

* Puedo comprobar la instalación viendo la versión:
>tsc --help
>npm -g ls 
>ts-node --version
NOTA:fijate que puedo instalar VSCode al path desde settings y tipeando 'install path'.Ya lo hace él.Se recomienda instalar Prettier.
También es buena idea ir a Preferences y activar Format On Save.

						VIDEO 570 FIRST APP

Recuerda que el principal objetivo es que TS me ayude a ver los errores ANTES de ejecutar la aplicación en vez de después.

Para compilar un archivo en TS hay que usar tsc fileName.Esto creará su réplica en un .js:
>tsc index.ts <- generará el .js.

Ahora ya podría ejecutar el .js con node:
>node index.js

Claro que tener que hacer esto todo el rato es una mala idea.Para juntar las funcionalidades de compilar con tsc y ejecutar con node está el módulo ts-node(el cual instalamos anteriormente).
Lógicamente recibe el archivo TYPESCRIPT:
>ts-node index.ts
En un sólo paso puedo compilar el ts y ejecutar el js.

					CATCHING ERRORS WIHT TS

Podriamos tratar de imprimir proiedades que no existen:

 console.log(`
   The Todo with ID: ${ID} 
   Has a title of: ${title}
   Is it finished? ${finished}
   `)

   The Todo with ID: undefined 
   Has a title of: undefined
   Is it finished? undefined

Esto sucede al trabajar con Javascript.Pero TS me va a ayudar con estos errores,para que no los tenga.
Sabiendo que realmente las propiedades son completed(y no finished),id(en minúsculas) y title(también en minúsculas) debería tipar la respuesta

interface Todo {
   id: number;
   title: string;
   completed: boolean;
}

axios.get<Todo>(url).then(response => {
   const todo = response.data;
   const ID = todo.id;
   const title = todo.title;
   const finished = todo.completed;

NOTA: las interfaces en TS se usan para definir la estructura de un objeto.Asi pues,habrá un objeto por ahí en mi app de tipo Todo con las props id,title y completed.

Fijate que podia haber casteado la response.data como un Todo(pues es una instancia):

axios.get(url).then(response => {
   const todo = response.data as Todo;

Quizás tipar la respuesta sería mejor opción en este caso,pero debo memorizar que puedo inferir cualquier propiedad con un tipado casteandola(instance as interfaceName).Interesante.
Ya puedo ejecutar el archivo y no debería ver los undefined anteriores.
Fijate que estoy cogiendo el error antes de la ejecución y no después.Esto es una clara muestra de que he cogido y evitado un error antes de la ejecución(y es el mero propósito de la razón de ser de TS).

Bien,y que sucederá si sacamos todo esto a una función y le paso los argumentos en cualquier orden?:

   logTodo(ID,finished,title);
})

const logTodo = (id,title,completed) => {
   console.log(`
   The Todo with ID: ${id} 
   Has a title of: ${title}
   Is it finished? ${completed}
   `)
}
Esto actualmente ya da un error.De todas formas,de nuevo comprobamos que no vemos el error hasta que ejecutamos el programa.Es aqui donde entran las 'type annotations'.En cuanto ponga un tipo a los argumentos ya no podré pasar un orden cualquiera:

   logTodo(ID,finished,title);
})

const logTodo = (id:number,title:string,finished:boolean)
Esto me dará un error ya antes de ejecutar el script,pues no puedo pasar un boleano cuando espera un string.

				VIDEO 575 OVERVIEW OF THE COURSE

El objetivo de este minicurso es entender la sintax+features y despues centrarnos en la implementación(design patterns) mediante aplicaciones didacticas(última sección 7).Asi que primero habrá conceptos teóricos.
El orden de la teoria será:

1- Understanding basic types
2- Function typing + annotations
3- Type definition files
4- Arrays in TS
5- Modules systems
6- Classes + Refresher on OOP
7- Projects( design patterns)

						VIDEO 576 TYPES 

En TS casi cualquier cosa que pueda tener un valor tiene un tipo.Una función tendrá su tipo,un array también,un objeto,una clase,...
IMPORTANTE: tipar una variable,objeto,array,.. no se hace sin ningun motivo.Si el lenguaje sabe de que tipo es cierto valor,sabrá que métodos puedo usar,qué propiedades,etc...Dar un tipado es muy importante.
Ejemplo: si red es un string el lenguaje sabré que puedo usar charAt,concat(),includes,endsWith,startsWith,indexOf,,localeCompare,match(),... y muchos métodos más prebuilt por el lenguaje solo por decir que la variable es de tipo string.
Como atajo a decir que la variable puede usar todos esos métodos lo que se hace es darle un simple y único nombre,en este caso 'string'.
Puedo ver un tipo como una etiqueta para identificar a qué métodos y propiedades tengo acceso

					VIDEO 577 MORE ON TYPES

En TS está el tipo Number,que en otros lenguajes suele subdividirse en varios,en este caso engloba cualquier tipo de numero.
En TS también está el tipo Date,por ejemplo.Veamos todos ellos:

Primitive: number,boolean,void,undefined,string,symbol,null
Object Types: function,array,class,object

Los types de TS se dividen en estas dos categorías,básicamente.
El tipado tiene dos grandes propósitos:
1- Ayudar a TS a que identifique los errore y me ayude
2- Ayudar a otros desarrolladores a que entiendan el código

Cada valor que declare en Typescript debe tener un tipo.

				VIDEO 579 FEATURE ONE - TYPING

Se debe tipar todo.Ejemplo:
const today = new Date(); <- TS me sugeriŕá métodos para una Date
Es por esto que se debe tipar todo.

		VIDEO 580 FEATURE TWO TYPE ANNOTATIONS + TYPE INFERENCE

Una type annotation es una pequeña pieza de código para decirle a TS de que tipo es una variable(:type)

Type inference: TS va a intentar averigüar por él mismo de qué tipo es una variable

Si bien parecen lo mismo en la primera soy yo el que le dice a TS el tipo,en la segunda lo averigüa TS por sí sólo.

// la sintaxis para una type annotation es :type
let apples: number = 5; //:number es la type annotation
// en cuanto anote a apples como number ya no podré pasarle como valor nada más que un number

let speed:string = "fast"; //:string es la type annotation
//de nuevo no podré reasignarla más que a otro string

let hasName: boolean = true; //:boolean es la type annotation

let nothingMuch: null = null; //:null es la type annotation
//este es el primer type annotation que coincide con su valor

let nothing:undefined = null; //:undefined es la type annotation
//este es el segundo type annotation que coincide con su valor

let now: Date = new Date(); //:Date es la type annotation

				VIDEO 581 OBJECT LITERAL ANNOTATIONS

Realmente ya śe todo esto,excepto el último(fijate que lo usé en event:{prop:type;prop:type}

/* Built in objects */
let now: Date = new Date(); //:Date es la type annotation
let colors: string[] = ["red", "green", "blue"]; 
let myNumbers: number[] = [1, 2, 3]; 
let truths:boolean[] = [true, false, true]; 

// Classes(siempre Capitalizadas)
class Car {}
let car: Car = new Car();
// Object literal
let point:{x:number; y:number} = { x: 10, y: 20 };
No confundir el type(que usa punto y coma) en la declaración con la inicialización del object(asignación de valores).

Las mismas reglas se aplican para estos tipos.NO podré asignar un valor que no coincida con estas type annotations de la izquierda:

let point:{x:number;y:number} <- point va a ser un object que tenga las props x e y,y me dará error si no las tiene,y serán number ambas.

				VIDEO 583 FUNCTION TYPE ANNOTATIONS

La type annotation para una función es un tanto compleja:
/* Function fijate en :(args) => return*/
const logNumber: (i:number) => void = (i: number) => {
   console.log(i);
   };
Fijate que lo que está a la izquierda del '=' siempre es el type annotation,da igual que sea una funcion,una clase,un object,...Lo de la izquierda es el tipo.

					VIDEO 584 TYPE INFERENCE

Si voy al archivo y borro todas las type annotations veré que no tengo error:
const apple=5; <- veré que es de tipo number.
const texto='hola'; <- veré que es de tipo string

NOTA: esto es el sistema de inferencia de tipos de TS.Pero,¿cuando puedo dejar a TS que infiera el tipo sin riesgo alguno?
Si hago la declaración e inicialización(asignación de valor/es) en la misma linea TS va a saber inferir el tipo correctamente(con lo que acabo de escribir medio file gratis -_-, mira que es prehistoric este TS).

NOTA: si TS no es capaz de inferirle el tipo porque separo la declaración e inicialización o es un tipo que no sabe inferir(como Color[]) siempre le va a poner de tipo 'any'.
Bien,entonces,¿si TS es capaz de inferir correctamente los types,cuando debo ser yo el que lo haga?Esto es una gran pregunta y hay una respuesta para ella:
1- cuando separe declaración e inicialización debo usar las types annotations yo o TS no sabrá qué es.
2- Cuando quiera usar un type que no puede ser inferido
3- Cuando una función devuelva 'any' y yo quiera ser más especifico.
Estos son los tres escenarios en los que tengo que tipar yo.El resto lo puede hacer TS.

					VIDEO 585 THE ANY TYPE

El tipo 'any' básicamente significa que Typescript no tiene ni idea que tipo de valor está siendo retornado(o asignado),asi que puede ser cualquiera.
La funcion JSON.parse() devuelve any,ya que puedo estar parseando cualquier cosa.Fijate que esto es el punto 3 que acabamos de comentar

IMPORTANTE: any es otro tipo más.Si algo es de tipo any TS no va a tener ni idea de que funciones,propiedades puede usar(adiós a los beneficios de un lenguaje tipado).HAY QUE EVITAR EL USO DE ANY A TODA COSTA.
La verdadera finalidad de tipar es encontrar errores antes de ejecutar el script,si usamos any TS no va a poder ayudar.

				VIDEO 586 FIXING THE ANY TYPE

En el ejemplo que teniamos,dado que JSON.parse devuelve any,aunque estemos en la misma linea tendré que ayudar a TS:

/* WHEN TO USE ANNOTATIONS BY ME */
// 1) Function that returns the 'any' type
const json = '{"x": 10, "y": 20}';
const coordinates:{ x:number; y:number } = JSON.parse(json);
console.log(coordinates); // {x: 10, y: 20}

				VIDEO 587 DELAYED INITIALIZATION

Siempre que use la inicialización en otra linea TS me va a tipar con 'any'.(fijate que veré tres puntitos sobre el warning).Este es un caso tonto pero muy explicito de que tengo que tipar foundWord con foundWord:boolean.

// 2) When we declare a variable on one line and initialize it later
let words = ["red", "green", "blue"];//aqui si infiere
let foundWord; //<- aqui no infiere

for (let i = 0; i < words.length; i++) {
    if (words[i] === "green") {
       foundWord = true; //es aqui donde la inicio
    }
}
La solución es darle el tipo en la declaración:
let foundWord:boolean;
* Fijate que asi se quita el warning y como TS me avisa.

				VIDEO 588 WHEN INFERENCE DOESN'T WORK

Puede haber casos en los que la inferencia no funcione bien:
let numbers = [-10, -1, 12];
let numberAboveZero = false;

for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
       numberAboveZero = numbers[i];
    }
}  
En este caso dará error al asignarle numbers[i] dado que TS infirió que es de tipo boolean.Para arreglar esto tendré que usar:
let numberAboveZero:number | boolean = false;

Puede haber situaciones en los que una variable necesite usar más de un tipo por cuestiones de lógica de negocio(aunque se recomienda evitar este tipo de escenarios)

			VIDEO 589 MORE ON ANNOTATIONS AROUND FUNCTIONS

Ya hemos terminado de ver como trabaja la inferencia con variables.Es hora de ver lo mismo para funciones.
Fijate que la anotación que hemos visto en realidad es para la variable,no para la función:
 const logNumber: (i:number) => void = (i:number) => {console.log(i)};<- esta anotación es para tipar la variable logNumber,no para la función(la función está despues del '=').

IMPORTANTE: en una función TS puede usar la inferencia de tipos para adivinar el valor de retorno de esa función.Como programadores nosotros tenemos que tipar los argumentos de la función y podemos tipar el retorno.
En la funciones el type inference sólo funciona para el retorno,TS nunca va a tratar de adivinar el tipado de los argumentos.Veamos todo esto en un ejemplo:

const add = (a,b) => {} <- TS nunca va a adivinar el tipo de 'a' y 'b'!

* Asi pues tengo que tipar los argumentos
const add = (a:number, b:number):number => {
    return a + b;
}
* Fijate que he tipado el valor de retorno también.

				VIDEO 590 INFERENCE AROUND FUNCIONS

En el momento en que yo como programador especifico un valor de retorno para una función TS va a analizar el cuerpo de esa función para ver si cumple.

Si quisiera retornar otro tipo de valor como un string TS dará un error:

const add = (a:number, b:number):number => {
    return "fsdffdff";
}

En cuanto a la inferencia de tipos en las funciones es muy importante entender que TS nunca va a mirar por si la lógica está bien,simplemente verá qué es lo que devuelve el body de la función y lo pondrá como tipo.
Esto es un error,ya que puedo haberme confundido en la lógica.Ejemplo:

const substract = (a:number, b:number) => {
  a - b;
} 
En este caso simplemente veré que es de tipo ():void pero yo no quería eso,se me olvidó el return.Lógicamente quiero que devuelva un Number.

Es por esto QUE NO USARÉ LA INFERENCIA DE TIPOS EN FUNCIONES PARA EL VALOR DE RETORNO,porque TS no comprueba la lógica del cuerpo de la función.

					VIDEO 591 MORE ON TYPES AROUND FUNCIONS

En cuanto a funciones normales o anónimas la sintaxis es prácticamente idéntica:
/* Cuando sea una función normal la sintaxis es igual */
function divide(a:number, b:number):number {
  return a / b;
}
/* Lo mismo para funciones anónimas */
const multiply = function(a:number, b:number):number {
  return a * b;
}

					VIDEO 592 TYPES VOID AND NEVER

También hay una type annotation para especificar que una función no tiene ningun valor de retorno,no retorna un valor:

const logger = (message:string):void => {
  console.log(message);
}

IMPORTANTE: una función que retorna void también puede retornar null o undefined!
const logger = (message:string) => {
  console.log(message);
  return null; <- o también return undefined;
}

Hay otro tipo también para especificar que nunca vamos a llegar al final de la función(a su return)por ejemplo porque tiramos un Error antes:
const throwError = (message:string): never => {
  throw new Error(message);

Técnicamente lanzar un Error es como no lanzar nada y además al lanzarlo nunca se va a llegar al return de esa función.Este es un ejemplo muy raro que apenas se usa.
Sólo debo usar este tipo cuando realmente sea lo que quiero hacer(normalmente los errores se usan dentro de otras funciones que retornan lo que necesiten):

const checkSomething = (something:string):string => {
  if(!something){ throw new Error('bla bla bla') };
  return something

Fijate que esto es tremendamente común

				VIDEO 593 DESTRUCTURING WITH ANNOTATIONS

Imagina que tengo un object literal con propiedades que son una función,algo muy común

const todaysWeather = { 
  date: new Date(),
  weather: 'sunny'
}

Ahora podría tener algo como esto:
const logWeather = (forecast:{ date:Date,weather:string }):void => {
  console.log(forecast.date);
  console.log(forecast.weather);
}
logWeather(todaysWeather);

Pero que pasa si quisiera usar destructuring?Realmente sólo tengo que cambiar forecast(el objeto) por la desestructuración

const logWeather2015 = ({date,weather}:{date:Date,weather:string}) => { } 

Bien fácil

NOTA: The semi-colon is used when we're annotating an object literal, not function parameters.
EDIT: Actually now it's not clear to me, because lecture 602. Long Type Annotations, he reverts back to using semi-colons when annotating the function parameters. From what I can see, semi-colon is the preferred style (and I think was the only way for a while) but now you can use either semi-colon or comma.
Parece que para usar una type annotation en un object literal hay que usar semicolon,pero no si está como argumento de una función,que permite tanto semicolon como comma.

					VIDEO ANNOTATIONS AROUND OBJECTS

Ya hemos visto type annotations con variables y funciones.Sólo nos quedan los objects:
/* Teniendo un object literal como este */
const profile = {
  name: 'John',
  age: 30,
  coords: {
    lat: 0,
    lng: 15
  },
  setAge(age:number):void{
    this.age = age;
  }
}
* Imagina que quiero desestructurar y tipar la edad.No voy a usar { age }:number aunque sepa que es un number porque realmente es de tipo profile.age,no number */

Lo que se hace es decir de que tipo de prop es y despues el tipo de esa prop
const { age }:{age:number} = profile;

Fijate que esto viola la regla anterior de :number,pero porque es la desestructuración de un object .Imagina que quisiera sacar el name también:

const { age, name }:number = profile;<- está claro que name no es de tipo number,asi que es const {age}:{age:number}=objectLiteral 

Esta sería la forma de sacar dos o más  propiedades,por cada una que saco la saco con su correspondiente par de  propName+:+propType
const { name,age:edad }:{name:string,age:number} = profile;

const { coords:{ lat, lng } }: {coords:{ lat:number;lng:number}} = profile;

Como puedo ver es bastante sencillo,sólo hay que trabajar más con ello.Además siempre tendré este tutorial para volver aqui si es necesario.

				VIDEO 595 ARRAYS IN TYPESCRIPT


